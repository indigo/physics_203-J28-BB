â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                   â•‘
â•‘              BILLARD MASTER 3D - CODE SOURCE COMPLET              â•‘
â•‘                                                                   â•‘
â•‘  SystÃ¨me UI complet avec menu, pause, dÃ©tection de victoire      â•‘
â•‘  Date: 13/12/2025 05:55:28                                        â•‘
â•‘                                                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 1/10 : index.html
  Lignes :       92
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billard Complet - Physique RÃ©aliste</title>
    <link rel="stylesheet" href="css/style.css">
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
        }
    }
    </script>
</head>
<body>
    <!-- UI CONTAINER -->
    <div id="ui-layer">
        
        <!-- 1. MAIN MENU -->
        <div id="screen-menu" class="screen" style="display: flex;">
            <h1 class="game-title">BILLARD MASTER 3D</h1>
            <div class="menu-buttons">
                <!-- NOUVEAU : Choix du mode -->
                <button id="btn-pve" class="btn primary">1 JOUEUR (vs BOT)</button>
                <button id="btn-pvp" class="btn">2 JOUEURS (LOCAL)</button>
                <button id="btn-bot-vs-bot" class="btn">ğŸ¤– BOT vs BOT ğŸ¤–</button>
                
                <button id="btn-settings" class="btn small">OPTIONS</button>
                <button id="btn-credits" class="btn small">CrÃ©dits</button>
            </div>
        </div>

        <!-- 2. SETTINGS -->
        <div id="screen-settings" class="screen" style="display: none;">
            <h2>OPTIONS</h2>
            <div class="setting-row">
                <label>Volume Musique</label>
                <input type="range" id="vol-music" min="0" max="1" step="0.1" value="0.5">
            </div>
            <div class="setting-row">
                <label>Volume SFX</label>
                <input type="range" id="vol-sfx" min="0" max="1" step="0.1" value="0.8">
            </div>
            <div class="setting-row">
                <label>Langue / Language</label>
                <select id="lang-select">
                    <option value="fr">FranÃ§ais</option>
                    <option value="en">English</option>
                </select>
            </div>
            <button id="btn-back-menu" class="btn">RETOUR</button>
        </div>

        <!-- 3. GAME HUD (Pendant le jeu) -->
        <div id="screen-hud" class="overlay" style="display: none;">
            <div class="top-bar">
                <div id="score-display">
                    <div class="player-name">Joueur 1</div>
                    <div id="player-balls" class="player-balls"></div>
                </div>
                <button id="btn-pause" class="btn-icon">â¸</button>
            </div>
            <div id="game-tips">
                Clic Bille: Viser | Glisser Blanche: Tirer
            </div>
        </div>

        <!-- 4. PAUSE MENU -->
        <div id="screen-pause" class="screen" style="display: none; background: rgba(0,0,0,0.8);">
            <h2>PAUSE</h2>
            <button id="btn-resume" class="btn primary">REPRENDRE</button>
            <button id="btn-settings-pause" class="btn">OPTIONS</button>
            <button id="btn-quit" class="btn danger">QUITTER</button>
        </div>

        <!-- 5. WIN / LOSE -->
        <div id="screen-gameover" class="screen" style="display: none;">
            <h1 id="end-title">VICTOIRE !</h1>
            <p id="end-message">Vous avez rentrÃ© la noire.</p>
            <button id="btn-restart" class="btn primary">REJOUER</button>
            <button id="btn-quit-end" class="btn">MENU PRINCIPAL</button>
        </div>

    </div>

    <script type="module" src="js/main.js"></script>
</body>
</html>


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 2/10 : css/style.css
  Lignes :      208
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

body { 
    margin: 0; 
    overflow: hidden; 
    background-color: #050505; 
    user-select: none; 
}

/* UI GLOBAL */
#ui-layer { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    pointer-events: none; 
}

.screen {
    position: absolute; 
    width: 100%; 
    height: 100%;
    background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center;
    pointer-events: auto;
    z-index: 10;
}

.overlay { 
    position: absolute; 
    width: 100%; 
    height: 100%; 
    pointer-events: none; 
}

/* TYPOGRAPHY */
h1.game-title { 
    font-size: 4em; 
    color: #17693b; 
    text-shadow: 0 2px 2px #d1dfd1; 
    margin-bottom: 50px; 
    font-family: 'Impact', sans-serif; 
    letter-spacing: 2px; 
}

h2 { 
    color: white; 
    font-family: sans-serif; 
    letter-spacing: 2px; 
}

p { 
    color: #ccc; 
    font-family: sans-serif; 
}

/* BUTTONS */
.btn {
    pointer-events: auto; 
    background: transparent; 
    border: 2px solid #555; 
    color: white;
    padding: 15px 40px; 
    margin: 10px; 
    font-size: 1.2em; 
    cursor: pointer;
    transition: all 0.2s; 
    font-family: sans-serif; 
    text-transform: uppercase; 
    min-width: 200px;
}

.btn:hover { 
    background: #333; 
    border-color: #888; 
    transform: scale(1.05); 
}

.btn.primary { 
    background: #2e8b57; 
    border-color: #2e8b57; 
    color: black; 
    font-weight: bold; 
}

.btn.primary:hover { 
    background: #3cb371; 
    color: white; 
}

.btn.danger { 
    border-color: #8b0000; 
    color: #ffcccc; 
}

.btn.danger:hover { 
    background: #8b0000; 
    color: white; 
}

.btn.small { 
    font-size: 0.8em; 
    padding: 5px 10px; 
    min-width: auto; 
    margin-top: 30px; 
    border: none; 
    color: #666; 
}

.btn-icon { 
    pointer-events: auto; 
    background: rgba(0,0,0,0.5); 
    border: none; 
    color: white; 
    font-size: 1.5em; 
    padding: 10px; 
    cursor: pointer; 
    border-radius: 5px; 
}

/* SETTINGS */
.setting-row { 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
    width: 300px; 
    margin: 10px 0; 
    color: white; 
    font-family: sans-serif; 
}

input[type=range] { 
    width: 150px; 
}

select { 
    padding: 5px; 
}

/* HUD */
.top-bar { 
    position: absolute; 
    top: 0; 
    width: 100%; 
    padding: 20px; 
    display: flex; 
    justify-content: space-between; 
    box-sizing: border-box; 
}

#score-display { 
    color: white; 
    font-family: sans-serif; 
    font-size: 1.5em; 
    background: rgba(0,0,0,0.5); 
    padding: 10px 15px; 
    border-radius: 5px; 
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.player-name {
    font-weight: bold;
}

.player-balls {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    font-size: 0.7em;
}

.ball-badge {
    background: linear-gradient(135deg, #444, #222);
    border: 1px solid #666;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

/* Couleurs des balles selon leur numÃ©ro */
.ball-badge.solid {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
}

.ball-badge.striped {
    background: linear-gradient(135deg, #f39c12, #e67e22);
    color: white;
}

#game-tips { 
    position: absolute; 
    bottom: 20px; 
    width: 100%; 
    text-align: center; 
    color: #888; 
    font-family: sans-serif; 
    text-shadow: 1px 1px 2px black; 
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 3/10 : js/constants.js
  Lignes :       27
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// constants.js
// Constantes physiques et dimensions de la table de billard

// --- CONSTANTES PHYSIQUES ---
export const BALL_RADIUS = 0.20;
export const BALL_MASS = 0.17;
export const GRAVITY = 9.81;
export const INERTIA = 0.4 * BALL_MASS * BALL_RADIUS * BALL_RADIUS; // Inertie d'une sphÃ¨re pleine : 2/5 * m * rÂ²

// Dimensions table
export const TABLE_W = 13.0;
export const TABLE_H = 7.0;

// Dimensions dÃ©taillÃ©es de la table
export const S = 0.007353;
export const VAL_CORNER_MOUTH = 115 * S;
export const VAL_SIDE_MOUTH = 150 * S;
export const VAL_OFFSET_CORNER = 50 * S;
export const VAL_OFFSET_SIDE = 78 * S;
export const VAL_HOLE_RADIUS = 80 * S;
export const CORNER_KNUCKLE = VAL_CORNER_MOUTH / Math.sqrt(2);
export const SIDE_KNUCKLE = VAL_SIDE_MOUTH / 2;
export const RAIL_HEIGHT = 0.32;
export const RUBBER_DEPTH = 0.40;
export const WOOD_DEPTH = 0.80;
export const FRAME_WIDTH = 1.2;
export const FRAME_HEIGHT = 0.45;


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 4/10 : js/gameState.js
  Lignes :      126
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// gameState.js
// Machine Ã  Ã©tats pour gÃ©rer les diffÃ©rentes phases du jeu

// --- GAME STATE MACHINE ---

export const GameStates = {
    MENU: 'menu',           // Main menu screen
    SETTINGS: 'settings',   // Settings screen
    IDLE: 'idle',           // Waiting for player interaction
    AIMING: 'aiming',       // Player is aiming the cue
    SHOOTING: 'shooting',   // Shot has been taken, balls are moving
    PAUSED: 'paused',       // Game is paused
    GAME_OVER: 'game_over'  // Game ended
};

class GameStateMachine {
    constructor() {
        this.currentState = GameStates.IDLE;
        this.listeners = [];
        
        // Gestion des joueurs (mode 2 joueurs)
        this.currentPlayer = 1; // 1 ou 2
        
        // Balles capturÃ©es par chaque joueur
        this.player1Balls = [];
        this.player2Balls = [];
    }

    setState(newState) {
        const oldState = this.currentState;
        this.currentState = newState;
        console.log(`Game state: ${oldState} -> ${newState}`);
        
        // Notify listeners
        this.listeners.forEach(listener => listener(newState, oldState));
    }

    getState() {
        return this.currentState;
    }

    isIdle() {
        return this.currentState === GameStates.IDLE;
    }

    isAiming() {
        return this.currentState === GameStates.AIMING;
    }

    isShooting() {
        return this.currentState === GameStates.SHOOTING;
    }

    canAim() {
        return this.currentState === GameStates.IDLE;
    }

    canShoot() {
        return this.currentState === GameStates.AIMING;
    }

    isMenu() {
        return this.currentState === GameStates.MENU;
    }

    isPaused() {
        return this.currentState === GameStates.PAUSED;
    }

    isSettings() {
        return this.currentState === GameStates.SETTINGS;
    }

    isPlaying() {
        return this.currentState === GameStates.IDLE || 
               this.currentState === GameStates.AIMING || 
               this.currentState === GameStates.SHOOTING;
    }

    // Add listener for state changes
    onStateChange(callback) {
        this.listeners.push(callback);
    }

    // Remove listener
    removeStateChangeListener(callback) {
        this.listeners = this.listeners.filter(l => l !== callback);
    }

    // Player management
    getCurrentPlayer() {
        return this.currentPlayer;
    }

    switchPlayer() {
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        console.log(`Changement de joueur â†’ Joueur ${this.currentPlayer}`);
        return this.currentPlayer;
    }
    
    resetPlayer() {
        this.currentPlayer = 1;
    }
    
    // Gestion des balles capturÃ©es
    addBallToCurrentPlayer(ballNumber) {
        if (this.currentPlayer === 1) {
            this.player1Balls.push(ballNumber);
        } else {
            this.player2Balls.push(ballNumber);
        }
        console.log(`Joueur ${this.currentPlayer} a capturÃ© la balle ${ballNumber}`);
    }
    
    getPlayerBalls(player) {
        return player === 1 ? this.player1Balls : this.player2Balls;
    }
    
    resetBalls() {
        this.player1Balls = [];
        this.player2Balls = [];
    }
}

// Export singleton instance
export const gameState = new GameStateMachine();


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 5/10 : js/materials.js
  Lignes :      192
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// materials.js
// SystÃ¨me de matÃ©riaux et shaders PBR pour la table de billard

import * as THREE from 'three';

/**
 * MatÃ©riau AVANCÃ‰ pour le tapis (Felt)
 * Utilise MeshStandardMaterial modifiÃ© via onBeforeCompile pour :
 * 1. Garder les ombres et l'Ã©clairage rÃ©aliste de la scÃ¨ne
 * 2. GÃ©nÃ©rer une texture de feutre procÃ©durale haute rÃ©solution
 */
export function createFeltMaterial() {
    const material = new THREE.MeshStandardMaterial({
        color: 0x1a8c35, // Vert billard de base (lÃ©gÃ¨rement plus sombre pour le contraste)
        roughness: 0.9,  // TrÃ¨s rugueux, ne brille pas comme du plastique
        metalness: 0.0,
        side: THREE.FrontSide
    });

    // Injection du shader personnalisÃ© dans le pipeline standard de Three.js
    material.onBeforeCompile = function(shader) {
        // 1. Uniformes : On augmente drastiquement l'Ã©chelle
        // Une Ã©chelle de 1.0 = des vagues de 1 mÃ¨tre
        // Une Ã©chelle de 1500.0 = des fibres de 1 millimÃ¨tre
        shader.uniforms.noiseScale = { value: 1000.0 }; 
        shader.uniforms.fiberIntensity = { value: 0.08 }; // Contraste du grain (ni trop fort, ni trop faible)
        
        // 2. Fonction de bruit "Hash" (Bruit statique)
        // C'est beaucoup mieux pour simuler du tissu/sable que le bruit de Perlin
        const noiseFunction = `
            // Hash sans sinus (plus rapide et plus "croustillant")
            float hash(vec2 p) {
                vec3 p3  = fract(vec3(p.xyx) * .1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }
            
            // Varying pour passer la position locale du vertex au fragment
            varying vec3 vLocalPosition;
        `;

        // Modification du Vertex Shader pour rÃ©cupÃ©rer la position locale
        // On utilise la position locale (le modÃ¨le 3D) plutÃ´t que les UVs pour Ã©viter les dÃ©formations
        shader.vertexShader = 'varying vec3 vLocalPosition;\n' + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            `
            #include <begin_vertex>
            vLocalPosition = position; // On capture la position brute du modÃ¨le
            `
        );
        
        // Modification du Fragment Shader
        shader.fragmentShader = noiseFunction + '\n' + shader.fragmentShader;
        shader.fragmentShader = 'uniform float noiseScale;\nuniform float fiberIntensity;\n' + shader.fragmentShader;

shader.fragmentShader = shader.fragmentShader.replace(
            '#include <map_fragment>',
            `
            #include <map_fragment>
            
            // --- 1. CALCUL DU GRAIN ---
            vec2 pos = vLocalPosition.xz;
            float grain = hash(pos * noiseScale);
            float microGrain = hash(pos * noiseScale * 3.5);
            float combinedGrain = (grain * 0.7 + microGrain * 0.3);
            
            // --- 2. EFFET DE VIGNETTE RECTANGULAIRE (CORRIGÃ‰) ---
            // Rappel : pos est un vec2, donc on utilise .x et .y
            
            // Axe X (Largeur ~13m) -> abs(pos.x)
            float edgeX = smoothstep(4.0, 6.5, abs(pos.x));
            
            // Axe Z (Profondeur ~7m) -> abs(pos.y) car c'est le 2eme composant du vec2
            float edgeZ = smoothstep(1.5, 3.5, abs(pos.y));
            
            // On prend le maximum des deux pour assombrir si on est prÃ¨s de n'importe quel bord
            float shadowStrength = max(edgeX, edgeZ);
            
            // Vignette finale : 1.0 au centre, 0.4 aux bords
            float vignette = 1.0 - (shadowStrength * 0.2); 
            
            // --- 3. APPLICATION SUR LA COULEUR ---
            // On modifie diffuseColor (variable interne de Three.js)
            vec3 finalColor = diffuseColor.rgb + (combinedGrain - 0.5) * fiberIntensity;
            
            // Appliquer la vignette
            finalColor *= vignette;

            diffuseColor.rgb = finalColor;
            `
        );
    };

    return material;}

/**
 * MatÃ©riau pour les bandes (cushions)
 * Caoutchouc/Tissu lÃ©gÃ¨rement diffÃ©rent
 */
export function createCushionMaterial() {
    return new THREE.MeshStandardMaterial({
        color: 0x146b2b, // Un peu plus foncÃ© que le tapis
        roughness: 0.85,
        metalness: 0.05
    });
}

/**
 * MatÃ©riau pour le cadre en bois
 * Ajout d'une texture procÃ©durale simple pour simuler des veines
 */
export function createWoodMaterial() {
    const mat = new THREE.MeshStandardMaterial({
        color: 0x5c3a21, // Bois acajou
        roughness: 0.3,  // Un peu brillant (vernis)
        metalness: 0.0
    });
    
    // Petite astuce : on peut ajouter une map ici si tu as une texture bois.jpg
    // Pour l'instant on reste procÃ©dural/couleur simple
    return mat;
}

/**
 * MatÃ©riau pour les trous (pockets)
 */
export function createPocketMaterial() {
    return new THREE.MeshStandardMaterial({
        color: 0x050505, // Presque noir
        roughness: 0.5,
        metalness: 0.1
    });
}

/**
 * MatÃ©riau pour les coins mÃ©talliques (si prÃ©sents dans ton modÃ¨le 3D)
 */
export function createChromeMaterial() {
    return new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.15,
        metalness: 0.9 // TrÃ¨s mÃ©tallique
    });
}

/**
 * Applique les matÃ©riaux appropriÃ©s au modÃ¨le GLB
 */
export function applyMaterialsToModel(model) {
    const feltMat = createFeltMaterial();
    const cushionMat = createCushionMaterial();
    const woodMat = createWoodMaterial();
    const pocketMat = createPocketMaterial();
    const chromeMat = createChromeMaterial();
    
    console.log('Application des matÃ©riaux PBR avancÃ©s...');
    
    model.traverse((child) => {
        if (child.isMesh) {
            // Ombres dynamiques (ESSENTIEL pour le rÃ©alisme)
            child.receiveShadow = true;
            child.castShadow = true;
            
            const name = child.name.toLowerCase();
            
            // Logique d'attribution intelligente
            if (name.includes('felt') || name.includes('tapis') || name.includes('surface')) {
                child.material = feltMat;
            }
            else if (name.includes('cushion') || name.includes('bande') || name.includes('rail')) {
                child.material = cushionMat;
            }
            else if (name.includes('wood') || name.includes('frame') || name.includes('cadre') || name.includes('bois')) {
                child.material = woodMat;
            }
            else if (name.includes('metal') || name.includes('chrome') || name.includes('corner')) {
                child.material = chromeMat;
            }
            else if (name.includes('pocket') || name.includes('liner') || name.includes('trou')) {
                child.material = pocketMat;
            }
            else {
                // Par dÃ©faut, on suppose que c'est du bois ou du dÃ©cor
                child.material = woodMat; 
            }
            
            // Correction pour Ã©viter les bugs d'affichage sur certains angles
            child.frustumCulled = false;
        }
    });
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 6/10 : js/ball.js
  Lignes :      140
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ball.js
// Classe BilliardBall avec physique de glissement, rotation et rendu

import * as THREE from 'three';
import { BALL_RADIUS, BALL_MASS, GRAVITY, INERTIA } from './constants.js';

// ParamÃ¨tres globaux (seront mis Ã  jour depuis main.js)
let params = null;

export function setParams(p) {
    params = p;
}

// --- CLASSE BALLE ---
export class BilliardBall {
    constructor(x, z, number) {
        this.number = number; // Store ball number for game logic
        this.pos = new THREE.Vector3(x, BALL_RADIUS, z);
        this.vel = new THREE.Vector3(0, 0, 0);
        this.angVel = new THREE.Vector3(0, 0, 0); // Vitesse angulaire (rad/s)
        this.quat = new THREE.Quaternion();
        this.inPocket = false;
        
        // Visuals
        const colors = {1:0xeebb00, 2:0x0000ee, 3:0xee0000, 4:0x800080, 5:0xffa500, 6:0x006400, 7:0x800000, 8:0x111111};
        let c = (number > 8 ? colors[number - 8] : colors[number]) || 0x000000;
        const geo = new THREE.SphereGeometry(BALL_RADIUS, 32, 16);
        const mat = new THREE.MeshStandardMaterial({ 
            map: this.createBallTexture(number, c), 
            roughness: 0.1, 
            metalness: 0.1 
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.castShadow = true;
        if (number !== 0) this.mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
        this.mesh.position.copy(this.pos);
    }

    createBallTexture(number, colorHex) {
        const size = 512;
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.canvas.width = size;
        ctx.canvas.height = size / 2;
        const w = size, h = size / 2;
        
        ctx.fillStyle = '#fffae6';
        ctx.fillRect(0, 0, w, h);
        
        if (number === 0) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.5, h * 0.05, 0, Math.PI * 2);
            ctx.fill();
            return new THREE.CanvasTexture(ctx.canvas);
        }
        
        ctx.fillStyle = '#' + new THREE.Color(colorHex).getHexString();
        if (number > 8) {
            ctx.fillRect(0, h * 0.25, w, h * 0.5);
        } else {
            ctx.fillRect(0, 0, w, h);
        }
        
        [w * 0.25, w * 0.75].forEach(x => {
            ctx.beginPath();
            ctx.arc(x, h * 0.5, h * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = '#fffae6';
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.font = `bold ${h * 0.4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, x, h * 0.52);
        });
        
        const t = new THREE.CanvasTexture(ctx.canvas);
        t.minFilter = THREE.LinearFilter;
        return t;
    }

    update(dt) {
        if (this.inPocket) return;

        // 1. Calcul de la vitesse relative au point de contact (v_slide)
        // v_contact = v + (omega x r)
        // r est le vecteur du centre vers le bas (0, -R, 0)
        const rVector = new THREE.Vector3(0, -BALL_RADIUS, 0);
        const vRot = new THREE.Vector3().crossVectors(this.angVel, rVector);
        const vSlide = new THREE.Vector3().addVectors(this.vel, vRot);
        vSlide.y = 0; // On reste sur le plan 2D

        const slideSpeed = vSlide.length();

        // 2. Application des forces
        if (slideSpeed > 0.01) {
            // --- ETAT GLISSEMENT (SLIDING) ---
            // Force de friction opposÃ©e au glissement
            const frictionDir = vSlide.normalize().negate();
            const frictionMag = params.muSlide * BALL_MASS * GRAVITY;
            const frictionForce = frictionDir.multiplyScalar(frictionMag);

            // a. Impact sur la vitesse linÃ©aire (F = ma)
            const linearAcc = frictionForce.clone().divideScalar(BALL_MASS);
            this.vel.addScaledVector(linearAcc, dt);

            // b. Impact sur la vitesse angulaire (Torque = r x F)
            const torque = new THREE.Vector3().crossVectors(rVector, frictionForce);
            const angularAcc = torque.divideScalar(INERTIA);
            this.angVel.addScaledVector(angularAcc, dt);
        } else {
            // --- ETAT ROULEMENT (ROLLING) ---
            // RÃ©sistance simple au roulement pour arrÃªter la bille progressivement
            const k = 1 - (params.muRoll * dt * 10);
            this.vel.multiplyScalar(k);
            this.angVel.multiplyScalar(k);
            
            // Seuil d'arrÃªt
            if (this.vel.lengthSq() < 0.0001) {
                this.vel.set(0, 0, 0);
                this.angVel.set(0, 0, 0);
            }
        }

        // 3. IntÃ©gration Position
        this.pos.addScaledVector(this.vel, dt);

        // 4. IntÃ©gration Rotation (Quaternion) via angVel rÃ©el
        const omegaLen = this.angVel.length();
        if (omegaLen > 0.000001) {
            const axis = this.angVel.clone().normalize();
            const angle = omegaLen * dt;
            const q = new THREE.Quaternion().setFromAxisAngle(axis, angle);
            this.quat.premultiply(q);
        }

        // 5. Mise Ã  jour Mesh
        this.mesh.position.copy(this.pos);
        this.mesh.quaternion.copy(this.quat);
    }
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 7/10 : js/table.js
  Lignes :      229
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// table.js
// Construction de la table de billard avec modÃ¨le 3D et physique

import * as THREE from 'three';
import { GLTFLoader } from 'jsm/loaders/GLTFLoader.js';
import { applyMaterialsToModel, createPocketMaterial } from './materials.js';
import { 
    TABLE_W, TABLE_H, RUBBER_DEPTH, RAIL_HEIGHT, WOOD_DEPTH, 
    FRAME_WIDTH, FRAME_HEIGHT, VAL_HOLE_RADIUS, VAL_OFFSET_CORNER, 
    VAL_OFFSET_SIDE, CORNER_KNUCKLE, SIDE_KNUCKLE, S
} from './constants.js';

export let walls2D = [];

export function createTable(scene) {
    // 1. CHARGER LE MODÃˆLE 3D (Visuel)
    const loader = new GLTFLoader();
    
    loader.load('assets/pool_table.glb', (gltf) => {
        const model = gltf.scene;
        
        console.log('ModÃ¨le GLB chargÃ© avec succÃ¨s');
        
        // Appliquer les matÃ©riaux avec le systÃ¨me de shaders
        applyMaterialsToModel(model);
        
        // Positionnement : Le modÃ¨le doit Ãªtre centrÃ© Ã  (0,0,0) dans Blender
        scene.add(model);
               // createFallbackTable(scene);
        console.log('ModÃ¨le 3D ajoutÃ© Ã  la scÃ¨ne');
        console.log('Position:', model.position);
        console.log('Ã‰chelle:', model.scale);
        
    }, undefined, (error) => {
        console.error('Erreur lors du chargement de la table 3D:', error);
        console.log('CrÃ©ation de la table procÃ©durale de secours...');
        createFallbackTable(scene);
    });

    // 2. GÃ‰NÃ‰RER LA PHYSIQUE (Invisible mais essentielle)
    walls2D = [];
    generatePhysicsBoundaries();
    
    // 3. Ajouter les trous visuels (cylindres noirs)
    createHoles(scene);
}

// Fonction de secours si le modÃ¨le GLB ne charge pas
function createFallbackTable(scene) {
    console.log('CrÃ©ation de la table procÃ©durale simple...');
    
    // Tapis principal
    const floorW = TABLE_W + (RUBBER_DEPTH + FRAME_WIDTH) * 2;
    const floorH = TABLE_H + (RUBBER_DEPTH + FRAME_WIDTH) * 2;
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(floorW, floorH), 
        new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness: 0.8 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);
    
    // Bandes simplifiÃ©es (4 rectangles)
    const cushionHeight = RAIL_HEIGHT;
    const cushionMat = new THREE.MeshStandardMaterial({ color: 0x247a46, roughness: 0.6 });
    
    // Bande Nord
    const northCushion = new THREE.Mesh(
        new THREE.BoxGeometry(TABLE_W, cushionHeight, RUBBER_DEPTH),
        cushionMat
    );
    northCushion.position.set(0, cushionHeight/2, -TABLE_H/2 - RUBBER_DEPTH/2);
    northCushion.castShadow = true;
    scene.add(northCushion);
    
    // Bande Sud
    const southCushion = new THREE.Mesh(
        new THREE.BoxGeometry(TABLE_W, cushionHeight, RUBBER_DEPTH),
        cushionMat
    );
    southCushion.position.set(0, cushionHeight/2, TABLE_H/2 + RUBBER_DEPTH/2);
    southCushion.castShadow = true;
    scene.add(southCushion);
    
    // Bande Est
    const eastCushion = new THREE.Mesh(
        new THREE.BoxGeometry(RUBBER_DEPTH, cushionHeight, TABLE_H + RUBBER_DEPTH * 2),
        cushionMat
    );
    eastCushion.position.set(TABLE_W/2 + RUBBER_DEPTH/2, cushionHeight/2, 0);
    eastCushion.castShadow = true;
    scene.add(eastCushion);
    
    // Bande Ouest
    const westCushion = new THREE.Mesh(
        new THREE.BoxGeometry(RUBBER_DEPTH, cushionHeight, TABLE_H + RUBBER_DEPTH * 2),
        cushionMat
    );
    westCushion.position.set(-TABLE_W/2 - RUBBER_DEPTH/2, cushionHeight/2, 0);
    westCushion.castShadow = true;
    scene.add(westCushion);
    
    // Cadre en bois
    const frameMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.4 });
    const frameThickness = FRAME_WIDTH;
    const frameH = FRAME_HEIGHT;
    
    // Cadre Nord
    const northFrame = new THREE.Mesh(
        new THREE.BoxGeometry(TABLE_W + RUBBER_DEPTH * 2 + frameThickness * 2, frameH, frameThickness),
        frameMat
    );
    northFrame.position.set(0, frameH/2, -TABLE_H/2 - RUBBER_DEPTH - frameThickness/2);
    scene.add(northFrame);
    
    // Cadre Sud
    const southFrame = new THREE.Mesh(
        new THREE.BoxGeometry(TABLE_W + RUBBER_DEPTH * 2 + frameThickness * 2, frameH, frameThickness),
        frameMat
    );
    southFrame.position.set(0, frameH/2, TABLE_H/2 + RUBBER_DEPTH + frameThickness/2);
    scene.add(southFrame);
    
    // Cadre Est
    const eastFrame = new THREE.Mesh(
        new THREE.BoxGeometry(frameThickness, frameH, TABLE_H + RUBBER_DEPTH * 2),
        frameMat
    );
    eastFrame.position.set(TABLE_W/2 + RUBBER_DEPTH + frameThickness/2, frameH/2, 0);
    scene.add(eastFrame);
    
    // Cadre Ouest
    const westFrame = new THREE.Mesh(
        new THREE.BoxGeometry(frameThickness, frameH, TABLE_H + RUBBER_DEPTH * 2),
        frameMat
    );
    westFrame.position.set(-TABLE_W/2 - RUBBER_DEPTH - frameThickness/2, frameH/2, 0);
    scene.add(westFrame);
}

// GÃ‰NÃ‰RATION DE LA PHYSIQUE (Murs invisibles)
function generatePhysicsBoundaries() {

    // Fonction pour construire les murs physiques (sans visuel)
    function buildPhysicsRail(p1, p2, normal) {
        const vecDir = new THREE.Vector3().subVectors(p2, p1).normalize();
        const facingSpread = RUBBER_DEPTH * 0.7;
        const p4 = p1.clone().add(normal.clone().multiplyScalar(RUBBER_DEPTH)).add(vecDir.clone().multiplyScalar(-facingSpread));
        const p3 = p2.clone().add(normal.clone().multiplyScalar(RUBBER_DEPTH)).add(vecDir.clone().multiplyScalar(facingSpread));

        // On ne crÃ©e plus de Mesh, juste les segments de collision
        addWallSegment(p4, p1);
        addWallSegment(p1, p2);
        addWallSegment(p2, p3);
    }

    function addWallSegment(a, b) {
        const dx = b.x - a.x;
        const dz = b.z - a.z;
        const len = Math.sqrt(dx * dx + dz * dz);
        walls2D.push({ 
            p1: a, 
            p2: b, 
            normal: { x: dz / len, z: -dx / len }, 
            lenSq: len * len 
        });
    }

    const W = TABLE_W / 2;
    const H = TABLE_H / 2;
    
    // Construire les 6 segments de bandes (physique uniquement)
    buildPhysicsRail(
        new THREE.Vector3(-W + CORNER_KNUCKLE, 0, -H), 
        new THREE.Vector3(-SIDE_KNUCKLE, 0, -H), 
        new THREE.Vector3(0, 0, -1)
    );
    buildPhysicsRail(
        new THREE.Vector3(SIDE_KNUCKLE, 0, -H), 
        new THREE.Vector3(W - CORNER_KNUCKLE, 0, -H), 
        new THREE.Vector3(0, 0, -1)
    );
    buildPhysicsRail(
        new THREE.Vector3(W, 0, -H + CORNER_KNUCKLE), 
        new THREE.Vector3(W, 0, H - CORNER_KNUCKLE), 
        new THREE.Vector3(1, 0, 0)
    );
    buildPhysicsRail(
        new THREE.Vector3(W - CORNER_KNUCKLE, 0, H), 
        new THREE.Vector3(SIDE_KNUCKLE, 0, H), 
        new THREE.Vector3(0, 0, 1)
    );
    buildPhysicsRail(
        new THREE.Vector3(-SIDE_KNUCKLE, 0, H), 
        new THREE.Vector3(-W + CORNER_KNUCKLE, 0, H), 
        new THREE.Vector3(0, 0, 1)
    );
    buildPhysicsRail(
        new THREE.Vector3(-W, 0, H - CORNER_KNUCKLE), 
        new THREE.Vector3(-W, 0, -H + CORNER_KNUCKLE), 
        new THREE.Vector3(-1, 0, 0)
    );
}

function createHoles(scene) {
    const holeGeo = new THREE.CylinderGeometry(VAL_HOLE_RADIUS, VAL_HOLE_RADIUS, 0.5, 32);
    const holeMat = createPocketMaterial();
    
    const W = TABLE_W / 2;
    const H = TABLE_H / 2;
    const dX = Math.cos(Math.PI / 4) * VAL_OFFSET_CORNER;
    const dZ = Math.sin(Math.PI / 4) * VAL_OFFSET_CORNER;
    
    const pp = [
        { x: -W - dX, z: -H - dZ },
        { x: W + dX, z: -H - dZ },
        { x: 0, z: -H - VAL_OFFSET_SIDE },
        { x: -W - dX, z: H + dZ },
        { x: W + dX, z: H + dZ },
        { x: 0, z: H + VAL_OFFSET_SIDE }
    ];
    
    pp.forEach(p => {
        const m = new THREE.Mesh(holeGeo, holeMat);
        m.position.set(p.x, -0.2, p.z);  // LÃ©gÃ¨rement plus bas pour Ã©viter le z-fighting
        m.renderOrder = -1;  // Rendre en premier pour Ã©viter les conflits
        scene.add(m);
    });
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 8/10 : js/physics.js
  Lignes :      139
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// physics.js
// Moteur physique : collisions, murs, trous et mise Ã  jour des billes

import * as THREE from 'three';
import { BALL_RADIUS, TABLE_W, TABLE_H, VAL_HOLE_RADIUS, VAL_OFFSET_CORNER, VAL_OFFSET_SIDE } from './constants.js';
import { walls2D } from './table.js';

// ParamÃ¨tres globaux
let params = null;

export function setParams(p) {
    params = p;
}

// --- MOTEUR PHYSIQUE ---
export function updatePhysics(balls, dt, turnInfo = null) {
    const sub = 15;
    const subDt = dt / sub;
    
    for (let s = 0; s < sub; s++) {
        // Collisions Balles (Choc Elastique Simple sur la vitesse linÃ©aire)
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                const b1 = balls[i], b2 = balls[j];
                if (b1.inPocket || b2.inPocket) continue;
                
                const dv = new THREE.Vector3().subVectors(b2.pos, b1.pos);
                const d = dv.length();
                
                if (d < BALL_RADIUS * 2) {
                    const n = dv.normalize();
                    const pen = (BALL_RADIUS * 2 - d) * 0.5;
                    
                    b1.pos.sub(n.clone().multiplyScalar(pen));
                    b2.pos.add(n.clone().multiplyScalar(pen));
                    
                    const vRel = new THREE.Vector3().subVectors(b1.vel, b2.vel).dot(n);
                    if (vRel < 0) continue;
                    
                    const imp = n.multiplyScalar(-(1 + params.restitution) * vRel * 0.5);
                    b1.vel.add(imp);
                    b2.vel.sub(imp);
                    
                    // Note : Le transfert de spin entre billes est ignorÃ© ici pour simplifier,
                    // mais la friction table/bille va rÃ©tablir le roulement naturel aprÃ¨s le choc.
                }
            }
        }

        balls.forEach(b => {
            // Murs 2D
            for (let w of walls2D) {
                const abx = w.p2.x - w.p1.x;
                const abz = w.p2.z - w.p1.z;
                const apx = b.pos.x - w.p1.x;
                const apz = b.pos.z - w.p1.z;
                
                let t = (apx * abx + apz * abz) / w.lenSq;
                t = Math.max(0, Math.min(1, t));
                
                const cx = w.p1.x + t * abx;
                const cz = w.p1.z + t * abz;
                const dx = b.pos.x - cx;
                const dz = b.pos.z - cz;
                const dSq = dx * dx + dz * dz;
                
                if (dSq < BALL_RADIUS * BALL_RADIUS) {
                    const dist = Math.sqrt(dSq);
                    let nx, nz;
                    
                    if (dist < 1e-5) {
                        nx = w.normal.x;
                        nz = w.normal.z;
                    } else {
                        nx = dx / dist;
                        nz = dz / dist;
                    }
                    
                    b.pos.x += nx * (BALL_RADIUS - dist);
                    b.pos.z += nz * (BALL_RADIUS - dist);
                    
                    const vn = b.vel.x * nx + b.vel.z * nz;
                    if (vn < 0) {
                        const j = -(1 + params.wallRestitution) * vn;
                        b.vel.x += nx * j;
                        b.vel.z += nz * j;
                        // On rÃ©duit un peu le spin au contact bande
                        b.angVel.multiplyScalar(0.9);
                    }
                }
            }

            // Trous
            const W = TABLE_W / 2;
            const H = TABLE_H / 2;
            const dX = Math.cos(Math.PI / 4) * VAL_OFFSET_CORNER;
            const dZ = Math.sin(Math.PI / 4) * VAL_OFFSET_CORNER;
            
            const pp = [
                { x: -W - dX, z: -H - dZ },
                { x: W + dX, z: -H - dZ },
                { x: 0, z: -H - VAL_OFFSET_SIDE },
                { x: -W - dX, z: H + dZ },
                { x: W + dX, z: H + dZ },
                { x: 0, z: H + VAL_OFFSET_SIDE }
            ];
            
            for (let p of pp) {
                const dx = b.pos.x - p.x;
                const dz = b.pos.z - p.z;
                if (dx * dx + dz * dz < VAL_HOLE_RADIUS * VAL_HOLE_RADIUS) {
                    if (!b.inPocket) { // Ã‰viter de compter plusieurs fois
                        b.inPocket = true;
                        b.vel.set(0, 0, 0);
                        b.angVel.set(0, 0, 0);
                        b.mesh.visible = false;
                        
                        // Enregistrer l'Ã©vÃ©nement pour le systÃ¨me de tour
                        if (turnInfo) {
                            if (b === window.whiteBall) {
                                turnInfo.whiteScratched = true;
                                setTimeout(() => window.resetWhiteBall(), 1000);
                            } else {
                                // Bille normale empochÃ©e
                                turnInfo.ballsPotted.push(b.number);
                                console.log(`Bille ${b.number} empochÃ©e`);
                            }
                        } else if (b === window.whiteBall) {
                            setTimeout(() => window.resetWhiteBall(), 1000);
                        }
                    }
                }
            }

            // Mise Ã  jour Physique (Frottement, Rotation, Glissement)
            b.update(subDt);
        });
    }
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 9/10 : js/simulator.js
  Lignes :      261
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// simulator.js
// Simulateur de physique pour prÃ©dire les rÃ©sultats des tirs (utilisÃ© par le bot)

import * as THREE from 'three';
import { BALL_RADIUS, BALL_MASS, TABLE_W, TABLE_H, VAL_HOLE_RADIUS, VAL_OFFSET_CORNER, VAL_OFFSET_SIDE } from './constants.js';
import { walls2D } from './table.js';

export class PhysicsSimulator {
    constructor() {
        this.maxSteps = 500; // Nombre max d'itÃ©rations de simulation
        this.dt = 0.016; // Pas de temps (16ms)
        this.subSteps = 15; // Sous-Ã©tapes pour la prÃ©cision
        
        // ParamÃ¨tres physiques (copiÃ©s de physics.js)
        this.muSlide = 0.2;
        this.muRoll = 0.07;
        this.restitution = 0.90;
        this.wallRestitution = 0.6;
    }

    /**
     * Simule un tir complet et retourne les Ã©vÃ©nements
     * @param {number} angle - Angle du tir
     * @param {number} power - Puissance du tir
     * @param {number} cueHeight - Hauteur du point d'impact (effet)
     * @param {Array} balls - Tableau des billes actuelles
     * @param {Object} whiteBall - La bille blanche
     * @returns {Object} RÃ©sultat de la simulation
     */
    simulateShot(angle, power, cueHeight, balls, whiteBall) {
        // Cloner l'Ã©tat actuel des billes pour ne pas modifier l'original
        const simBalls = this.cloneBalls(balls);
        const simWhite = simBalls.find(b => b.number === 0);
        
        // Appliquer le tir initial
        const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
        simWhite.vel.copy(dir.clone().multiplyScalar(power));
        
        // Appliquer l'effet (spin) si nÃ©cessaire
        if (cueHeight !== 0) {
            const impactPoint = new THREE.Vector3(0, cueHeight, 0);
            const forceDir = dir.clone();
            const forceMag = power * BALL_MASS * 50;
            const forceVec = forceDir.multiplyScalar(forceMag);
            const torque = new THREE.Vector3().crossVectors(impactPoint, forceVec);
            const INERTIA = 0.4 * BALL_MASS * BALL_RADIUS * BALL_RADIUS;
            const impulseDt = 0.01;
            simWhite.angVel.add(torque.divideScalar(INERTIA).multiplyScalar(impulseDt));
        }
        
        // Ã‰vÃ©nements Ã  tracker
        const events = {
            ballsPotted: [],
            whiteScratched: false,
            finalWhitePos: null,
            finalBallPositions: [],
            collisions: [],
            stoppedAt: 0
        };
        
        // Simulation de la physique
        let step = 0;
        while (step < this.maxSteps) {
            const allStopped = this.simulateStep(simBalls, events);
            
            if (allStopped) {
                events.stoppedAt = step;
                break;
            }
            
            step++;
        }
        
        // Enregistrer les positions finales
        events.finalWhitePos = simWhite.pos.clone();
        events.finalBallPositions = simBalls.map(b => ({
            number: b.number,
            pos: b.pos.clone(),
            inPocket: b.inPocket
        }));
        
        return events;
    }

    /**
     * Clone les billes pour la simulation
     */
    cloneBalls(balls) {
        return balls.map(ball => ({
            number: ball.number,
            pos: ball.pos.clone(),
            vel: ball.vel.clone(),
            angVel: ball.angVel.clone(),
            inPocket: ball.inPocket,
            mesh: null // Pas besoin du mesh dans la simulation
        }));
    }

    /**
     * Simule un pas de temps
     */
    simulateStep(balls, events) {
        const subDt = this.dt / this.subSteps;
        
        for (let s = 0; s < this.subSteps; s++) {
            // Collisions entre billes
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const b1 = balls[i], b2 = balls[j];
                    if (b1.inPocket || b2.inPocket) continue;
                    
                    const dv = new THREE.Vector3().subVectors(b2.pos, b1.pos);
                    const d = dv.length();
                    
                    if (d < BALL_RADIUS * 2) {
                        const n = dv.normalize();
                        const pen = (BALL_RADIUS * 2 - d) * 0.5;
                        
                        b1.pos.sub(n.clone().multiplyScalar(pen));
                        b2.pos.add(n.clone().multiplyScalar(pen));
                        
                        const vRel = new THREE.Vector3().subVectors(b1.vel, b2.vel).dot(n);
                        if (vRel < 0) continue;
                        
                        const imp = n.multiplyScalar(-(1 + this.restitution) * vRel * 0.5);
                        b1.vel.add(imp);
                        b2.vel.sub(imp);
                        
                        // Enregistrer la collision
                        events.collisions.push({ ball1: b1.number, ball2: b2.number });
                    }
                }
            }

            // Collisions avec les murs
            balls.forEach(b => {
                if (b.inPocket) return;
                
                for (let w of walls2D) {
                    const abx = w.p2.x - w.p1.x;
                    const abz = w.p2.z - w.p1.z;
                    const apx = b.pos.x - w.p1.x;
                    const apz = b.pos.z - w.p1.z;
                    
                    let t = (apx * abx + apz * abz) / w.lenSq;
                    t = Math.max(0, Math.min(1, t));
                    
                    const cx = w.p1.x + t * abx;
                    const cz = w.p1.z + t * abz;
                    const dx = b.pos.x - cx;
                    const dz = b.pos.z - cz;
                    const dSq = dx * dx + dz * dz;
                    
                    if (dSq < BALL_RADIUS * BALL_RADIUS) {
                        const dist = Math.sqrt(dSq);
                        let nx, nz;
                        
                        if (dist < 1e-5) {
                            nx = w.normal.x;
                            nz = w.normal.z;
                        } else {
                            nx = dx / dist;
                            nz = dz / dist;
                        }
                        
                        b.pos.x += nx * (BALL_RADIUS - dist);
                        b.pos.z += nz * (BALL_RADIUS - dist);
                        
                        const vn = b.vel.x * nx + b.vel.z * nz;
                        if (vn < 0) {
                            const j = -(1 + this.wallRestitution) * vn;
                            b.vel.x += nx * j;
                            b.vel.z += nz * j;
                            b.angVel.multiplyScalar(0.9);
                        }
                    }
                }

                // DÃ©tection des trous
                this.checkPockets(b, events);

                // Mise Ã  jour physique (friction, etc.)
                this.updateBallPhysics(b, subDt);
            });
        }
        
        // VÃ©rifier si toutes les billes sont arrÃªtÃ©es
        return balls.every(b => b.inPocket || b.vel.lengthSq() < 0.0001);
    }

    /**
     * VÃ©rifie si une bille tombe dans un trou
     */
    checkPockets(ball, events) {
        if (ball.inPocket) return;
        
        const W = TABLE_W / 2;
        const H = TABLE_H / 2;
        const dX = Math.cos(Math.PI / 4) * VAL_OFFSET_CORNER;
        const dZ = Math.sin(Math.PI / 4) * VAL_OFFSET_CORNER;
        
        const pockets = [
            { x: -W - dX, z: -H - dZ },
            { x: W + dX, z: -H - dZ },
            { x: 0, z: -H - VAL_OFFSET_SIDE },
            { x: -W - dX, z: H + dZ },
            { x: W + dX, z: H + dZ },
            { x: 0, z: H + VAL_OFFSET_SIDE }
        ];
        
        for (let p of pockets) {
            const dx = ball.pos.x - p.x;
            const dz = ball.pos.z - p.z;
            if (dx * dx + dz * dz < VAL_HOLE_RADIUS * VAL_HOLE_RADIUS) {
                ball.inPocket = true;
                ball.vel.set(0, 0, 0);
                ball.angVel.set(0, 0, 0);
                
                if (ball.number === 0) {
                    events.whiteScratched = true;
                } else {
                    events.ballsPotted.push(ball.number);
                }
                break;
            }
        }
    }

    /**
     * Met Ã  jour la physique d'une bille (friction, roulement)
     */
    updateBallPhysics(ball, dt) {
        if (ball.inPocket) return;
        
        const speed = ball.vel.length();
        if (speed < 0.001) {
            ball.vel.set(0, 0, 0);
            ball.angVel.set(0, 0, 0);
            return;
        }
        
        // Friction de glissement
        const frictionForce = this.muSlide * BALL_MASS * 9.81;
        const frictionAcc = frictionForce / BALL_MASS;
        const velDir = ball.vel.clone().normalize();
        ball.vel.sub(velDir.multiplyScalar(frictionAcc * dt));
        
        // Friction de roulement
        const rollResistance = this.muRoll * 9.81;
        const newSpeed = Math.max(0, speed - rollResistance * dt);
        if (speed > 0) {
            ball.vel.multiplyScalar(newSpeed / speed);
        }
        
        // DÃ©croissance du spin
        ball.angVel.multiplyScalar(Math.max(0, 1 - dt * 2));
        
        // Mise Ã  jour de la position
        ball.pos.add(ball.vel.clone().multiplyScalar(dt));
    }
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 10/10 : js/smartBot.js
  Lignes :      233
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// smartBot.js
// Bot intelligent avec simulation de physique pour jouer au billard

import * as THREE from 'three';
import { PhysicsSimulator } from './simulator.js';
import { TABLE_W, TABLE_H, BALL_RADIUS } from './constants.js';
import { gameState } from './gameState.js';
import { focusCameraOnTarget } from './ui.js';

export class SmartBot {
    constructor(difficulty = 0.5) {
        this.simulator = new PhysicsSimulator();
        this.difficulty = difficulty; // 0 (Stupide) Ã  1 (Dieu)
        this.isThinking = false;
    }

    /**
     * Le bot joue son tour
     * @param {Object} whiteBall - La bille blanche
     * @param {Array} balls - Toutes les billes
     * @param {Function} shootCallback - Fonction pour tirer (angle, power)
     */
    async playTurn(whiteBall, balls, shootCallback) {
        if (this.isThinking) return;
        this.isThinking = true;
        
        console.log("ğŸ§  Le Bot rÃ©flÃ©chit...");
        
        // 1. Identifier mes cibles
        const myBalls = this.getTargets(balls);
        if (myBalls.length === 0) {
            console.log("âš ï¸ Aucune cible disponible");
            this.isThinking = false;
            return;
        }

        let bestShot = null;
        let maxScore = -Infinity;

        // 2. Bruteforce intelligent
        // On teste chaque bille ciblable vers chaque trou possible
        const pockets = this.getPockets();
        
        console.log(`ğŸ¯ Analyse de ${myBalls.length} cibles Ã— ${pockets.length} trous...`);

        for (let target of myBalls) {
            // ğŸ¥ VISUALISATION : DÃ©placer la camÃ©ra vers la bille Ã©valuÃ©e
            focusCameraOnTarget(target);
            
            // Petit dÃ©lai pour voir la camÃ©ra bouger (effet "rÃ©flexion")
            await new Promise(r => setTimeout(r, 200));
            
            for (let pocket of pockets) {
                
                // Calcul gÃ©omÃ©trique de base (Angle thÃ©orique)
                const aimParams = this.calculateGeometricAim(whiteBall.pos, target.pos, pocket);
                if (!aimParams) continue; // Pas de ligne de vue directe (optionnel)

                // 3. LA SIMULATION
                // On simule ce tir exact
                const simResult = this.simulator.simulateShot(
                    aimParams.angle, 
                    aimParams.power, 
                    0, // Pas d'effet pour l'instant pour le bot
                    balls, 
                    whiteBall
                );

                // 4. Scoring du rÃ©sultat
                const score = this.evaluateShot(simResult, target.number);

                if (score > maxScore) {
                    maxScore = score;
                    bestShot = { 
                        angle: aimParams.angle, 
                        power: aimParams.power,
                        target: target.number,
                        expectedPotted: simResult.ballsPotted
                    };
                }
            }
        }

        // Si aucun coup valide trouvÃ©, on tire au hasard (cas de snook)
        if (!bestShot) {
            console.log("ğŸ² Aucun bon coup trouvÃ©, tir alÃ©atoire");
            bestShot = { 
                angle: Math.random() * Math.PI * 2, 
                power: 15 + Math.random() * 10 
            };
        } else {
            console.log(`âœ… Meilleur coup: Cible ${bestShot.target}, Score ${maxScore.toFixed(0)}`);
            
            // ğŸ¥ VISUALISATION FINALE : Montrer la bille choisie
            const finalTarget = balls.find(b => b.number === bestShot.target);
            if (finalTarget) {
                focusCameraOnTarget(finalTarget);
                await new Promise(r => setTimeout(r, 500)); // Pause pour bien voir
            }
        }

        // 5. Application de l'erreur humaine (BasÃ©e sur la difficultÃ©)
        // Un bot pro a une dÃ©viation de 0.01 rad, un dÃ©butant de 0.2 rad
        const errorMargin = (1 - this.difficulty) * 0.2; 
        const finalAngle = bestShot.angle + (Math.random() - 0.5) * errorMargin;
        const finalPower = bestShot.power + (Math.random() - 0.5) * (1 - this.difficulty) * 5;

        // DÃ©lai pour le rÃ©alisme
        await new Promise(r => setTimeout(r, 800 + Math.random() * 500));
        
        console.log(`ğŸ± Bot tire: angle=${(finalAngle * 180 / Math.PI).toFixed(1)}Â°, power=${finalPower.toFixed(1)}`);
        
        shootCallback(finalAngle, finalPower);
        this.isThinking = false;
    }

    /**
     * Ã‰value la qualitÃ© d'un tir simulÃ©
     * @param {Object} simEvents - RÃ©sultat de la simulation
     * @param {number} targetNumber - NumÃ©ro de la bille ciblÃ©e
     * @returns {number} Score du tir
     */
    evaluateShot(simEvents, targetNumber) {
        let score = 0;

        // CRITIQUE : Ne pas empocher la blanche
        if (simEvents.whiteScratched) return -10000;

        // POSITIF : Empocher la bonne bille
        if (simEvents.ballsPotted.includes(targetNumber)) {
            score += 1000;
        }

        // BONUS : Empocher plusieurs billes d'un coup
        const validPots = simEvents.ballsPotted.filter(n => n !== 0 && n !== 8);
        score += validPots.length * 500;

        // NÃ‰GATIF : Empocher la noire trop tÃ´t
        if (simEvents.ballsPotted.includes(8)) {
            score -= 5000;
        }

        // STRATÃ‰GIQUE : Placement de la blanche
        // Si je suis un pro (difficulty > 0.8), je veux que la blanche finisse au centre
        if (this.difficulty > 0.8 && simEvents.finalWhitePos) {
            const distToCenter = simEvents.finalWhitePos.length(); // distance de (0,0,0)
            score -= distToCenter * 10; // On prÃ©fÃ¨re le centre
        }

        // BONUS : Nombre de collisions (plus il y en a, plus c'est risquÃ©)
        if (this.difficulty > 0.5) {
            score -= simEvents.collisions.length * 5;
        }

        // BONUS : ArrÃªt rapide (moins de risques)
        score += (this.simulator.maxSteps - simEvents.stoppedAt) * 0.5;

        return score;
    }

    /**
     * Calcule l'angle et la puissance pour viser une bille vers un trou
     * @param {THREE.Vector3} whitePos - Position de la blanche
     * @param {THREE.Vector3} targetPos - Position de la cible
     * @param {THREE.Vector3} pocketPos - Position du trou
     * @returns {Object|null} {angle, power} ou null si impossible
     */
    calculateGeometricAim(whitePos, targetPos, pocketPos) {
        // Vecteur Cible -> Trou
        const toPocket = new THREE.Vector3().subVectors(pocketPos, targetPos).normalize();
        
        // Point fantÃ´me derriÃ¨re la cible (oÃ¹ doit frapper la blanche)
        const ghostPos = targetPos.clone().sub(toPocket.clone().multiplyScalar(BALL_RADIUS * 2));
        
        // Vecteur de tir (Blanche -> Point fantÃ´me)
        const shootDir = new THREE.Vector3().subVectors(ghostPos, whitePos);
        const distance = shootDir.length();
        
        // VÃ©rification basique : la blanche n'est pas trop proche
        if (distance < BALL_RADIUS * 2.5) return null;
        
        // Calcul de la puissance en fonction de la distance
        // Distance courte = puissance faible, distance longue = puissance forte
        const basePower = 15;
        const powerFactor = Math.min(distance / 10, 1.5); // Normaliser
        const power = basePower + powerFactor * 10;
        
        return {
            angle: Math.atan2(shootDir.z, shootDir.x),
            power: Math.min(power, 25) // Limiter la puissance max
        };
    }

    /**
     * RÃ©cupÃ¨re les billes ciblables pour le joueur actuel
     * @param {Array} balls - Toutes les billes
     * @returns {Array} Billes ciblables
     */
    getTargets(balls) {
        // VÃ©rifier si toutes les billes rÃ©guliÃ¨res sont empochÃ©es
        const regularBalls = balls.filter(b => b.number !== 0 && b.number !== 8 && !b.inPocket);
        
        // Si toutes les billes rÃ©guliÃ¨res sont empochÃ©es, viser la noire (8)
        if (regularBalls.length === 0) {
            const blackBall = balls.find(b => b.number === 8 && !b.inPocket);
            return blackBall ? [blackBall] : [];
        }
        
        // Sinon, viser les billes rÃ©guliÃ¨res (tout sauf blanche et noire)
        return regularBalls;
    }

    /**
     * Retourne les positions des 6 trous
     * @returns {Array<THREE.Vector3>} Positions des trous
     */
    getPockets() {
        const W = TABLE_W / 2;
        const H = TABLE_H / 2;
        const dX = Math.cos(Math.PI / 4) * 0.368; // VAL_OFFSET_CORNER
        const dZ = Math.sin(Math.PI / 4) * 0.368;
        const sideOffset = 0.574; // VAL_OFFSET_SIDE
        
        return [
            new THREE.Vector3(-W - dX, 0, -H - dZ),  // Coin haut-gauche
            new THREE.Vector3(W + dX, 0, -H - dZ),   // Coin haut-droit
            new THREE.Vector3(0, 0, -H - sideOffset), // Milieu haut
            new THREE.Vector3(-W - dX, 0, H + dZ),   // Coin bas-gauche
            new THREE.Vector3(W + dX, 0, H + dZ),    // Coin bas-droit
            new THREE.Vector3(0, 0, H + sideOffset)  // Milieu bas
        ];
    }
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 11/10 : js/botManager.js
  Lignes :      100
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// botManager.js
// Gestion du bot IA dans le jeu

import { SmartBot } from './smartBot.js';
import { gameState } from './gameState.js';

export class BotManager {
    constructor() {
        this.bot = null;
        this.bot2 = null; // DeuxiÃ¨me bot pour le mode Bot vs Bot
        this.isEnabled = false;
        this.botPlayer = 2; // Le bot joue en tant que Joueur 2 par dÃ©faut
        this.difficulty = 0.5; // DifficultÃ© moyenne par dÃ©faut
        this.isBotVsBot = false; // Mode Bot vs Bot
    }

    /**
     * Active ou dÃ©sactive le bot
     */
    setEnabled(enabled, difficulty = 0.5) {
        this.isEnabled = enabled;
        this.difficulty = difficulty;
        this.isBotVsBot = false;
        
        if (enabled && !this.bot) {
            this.bot = new SmartBot(difficulty);
            console.log(`ğŸ¤– Bot activÃ© (difficultÃ©: ${(difficulty * 100).toFixed(0)}%)`);
        } else if (!enabled) {
            console.log('ğŸ¤– Bot dÃ©sactivÃ©');
        }
    }

    /**
     * Active le mode Bot vs Bot
     */
    setBotVsBot(difficulty1 = 0.6, difficulty2 = 0.7) {
        this.isEnabled = true;
        this.isBotVsBot = true;
        this.bot = new SmartBot(difficulty1);
        this.bot2 = new SmartBot(difficulty2);
        console.log(`ğŸ¤– Mode Bot vs Bot activÃ©`);
        console.log(`   Bot 1 (Joueur 1): ${(difficulty1 * 100).toFixed(0)}%`);
        console.log(`   Bot 2 (Joueur 2): ${(difficulty2 * 100).toFixed(0)}%`);
    }

    /**
     * Change la difficultÃ© du bot
     */
    setDifficulty(difficulty) {
        this.difficulty = difficulty;
        if (this.bot) {
            this.bot.difficulty = difficulty;
            console.log(`ğŸ¤– DifficultÃ© du bot: ${(difficulty * 100).toFixed(0)}%`);
        }
    }

    /**
     * DÃ©finit quel joueur est le bot
     */
    setBotPlayer(playerNumber) {
        this.botPlayer = playerNumber;
        console.log(`ğŸ¤– Le bot joue en tant que Joueur ${playerNumber}`);
    }

    /**
     * VÃ©rifie si c'est au tour du bot de jouer
     */
    shouldBotPlay() {
        if (!this.isEnabled || !gameState.isIdle()) return false;
        
        // Mode Bot vs Bot : les deux joueurs sont des bots
        if (this.isBotVsBot) return true;
        
        // Mode PvE : seulement le botPlayer est un bot
        return gameState.getCurrentPlayer() === this.botPlayer;
    }

    /**
     * Fait jouer le bot
     */
    async playBotTurn(whiteBall, balls, shootCallback) {
        if (!this.shouldBotPlay()) return;
        
        const currentPlayer = gameState.getCurrentPlayer();
        
        // Mode Bot vs Bot : choisir le bon bot
        if (this.isBotVsBot) {
            const activeBot = currentPlayer === 1 ? this.bot : this.bot2;
            console.log(`ğŸ¤– Bot ${currentPlayer} rÃ©flÃ©chit...`);
            await activeBot.playTurn(whiteBall, balls, shootCallback);
        } else {
            // Mode PvE : un seul bot
            console.log(`ğŸ¤– C'est au tour du bot (Joueur ${this.botPlayer})`);
            await this.bot.playTurn(whiteBall, balls, shootCallback);
        }
    }
}

// Instance singleton
export const botManager = new BotManager();


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 12/10 : js/ui.js
  Lignes :      200
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ui.js
// Interface utilisateur : GUI, contrÃ´les de visÃ©e et gestion des Ã©vÃ©nements

import * as THREE from 'three';
import GUI from 'lil-gui';
import { BALL_RADIUS, TABLE_W, TABLE_H } from './constants.js';
import { gameState, GameStates } from './gameState.js';
import { PhysicsSimulator } from './simulator.js';

// Variables globales
let scene, camera, controls, whiteBall, cueStick, aimLine;
let params = null;
let simulator = new PhysicsSimulator();
let guideLines = [];

// Ã‰tat de la souris
const mouseState = {
    isAiming: false,
    startPos: new THREE.Vector3(),
    currentPos: new THREE.Vector3(),
    power: 0,
    angle: 0
};

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const planeY = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

export function setGlobalVariables(s, c, ctrls, wb, cs, al, p) {
    scene = s;
    camera = c;
    controls = ctrls;
    whiteBall = wb;
    cueStick = cs;
    aimLine = al;
    params = p;
}

export function updateWhiteBall(wb) {
    whiteBall = wb;
}

export function setupGUI(params) {
    const gui = new GUI({ title: 'Billard Pro' });
    gui.add(params, 'cueHeight', -BALL_RADIUS * 0.8, BALL_RADIUS * 0.8).name('Effet (Haut/Bas)');
    gui.add(params, 'showDebug').name('Ligne de visÃ©e (Cheat)').onChange(v => clearGuideLines());
    return gui;
}

export function setupEventListeners() {
    window.addEventListener('resize', onResize);
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    
    // --- SUPPORT MOBILE (TOUCH) ---
    window.addEventListener('touchstart', (e) => {
        if(e.touches.length > 0) {
            const touch = e.touches[0];
            const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY, target: e.target };
            onMouseDown(fakeEvent);
        }
    }, {passive: false});

    window.addEventListener('touchmove', (e) => {
        if(e.touches.length > 0) {
            const touch = e.touches[0];
            const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
            onMouseMove(fakeEvent);
        }
    }, {passive: false});

    window.addEventListener('touchend', (e) => {
        onMouseUp();
    });

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') window.resetGame();
    });
}

// --- LOGIQUE CAMERA & VISÃ‰E ---
function onMouseDown(e) {
    // Si on clique sur l'interface (boutons), on ignore
    if (e.target.closest && (e.target.closest('button') || e.target.closest('.screen'))) return;
    if (!gameState.canAim() || !gameState.isPlaying()) return;
    
    updateMouse(e);
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(window.balls.map(b => b.mesh));
    if (intersects.length > 0) {
        const hitObj = intersects[0].object;
        if (hitObj === whiteBall.mesh) {
            mouseState.isAiming = true;
            gameState.setState(GameStates.AIMING);
            controls.enabled = false;
            raycaster.ray.intersectPlane(planeY, mouseState.startPos);
            cueStick.visible = true;
            cueStick.position.y = BALL_RADIUS + params.cueHeight;
            aimLine.visible = true;
        } else {
            focusCameraOnTarget(window.balls.find(b => b.mesh === hitObj));
        }
    }
}

export function focusCameraOnTarget(target) {
    const direction = new THREE.Vector3().subVectors(target.pos, whiteBall.pos).normalize();
    const angle = Math.atan2(direction.z, direction.x);
    mouseState.angle = angle;
    
    // Position camÃ©ra type "TV Broadcast"
    const camPos = whiteBall.pos.clone()
        .sub(direction.clone().multiplyScalar(7))
        .add(new THREE.Vector3(0, 8, 0));
    
    camera.position.copy(camPos);
    controls.target.copy(whiteBall.pos);
    controls.update();
}

function onMouseMove(e) {
    if (!mouseState.isAiming) return;
    
    updateMouse(e);
    raycaster.setFromCamera(mouse, camera);
    raycaster.ray.intersectPlane(planeY, mouseState.currentPos);
    
    const v = new THREE.Vector3().subVectors(whiteBall.pos, mouseState.currentPos);
    const angle = Math.atan2(v.z, v.x);
    const dist = Math.min(v.length() * 3, params.maxPower);
    
    mouseState.angle = angle;
    mouseState.power = dist;

    cueStick.position.copy(whiteBall.pos);
    cueStick.position.y = BALL_RADIUS + params.cueHeight;
    cueStick.rotation.y = -angle - Math.PI / 2;
    cueStick.translateZ(dist * 0.1 + 0.2);

    aimLine.position.copy(whiteBall.pos);
    aimLine.rotation.y = -angle;

    // --- LE POUVOIR : Visualisation de trajectoire (Simulation) ---
    if (params.showDebug) {
        updatePredictionLine();
    }
}

function updatePredictionLine() {
    const result = simulator.simulateShot(
        mouseState.angle,
        mouseState.power,
        params.cueHeight,
        window.balls,
        window.whiteBall
    );

    clearGuideLines();
    const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 });
    
    if (result.finalWhitePos) {
        const points = [whiteBall.pos.clone(), result.finalWhitePos];
        points.forEach(p => p.y = BALL_RADIUS);
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        guideLines.push(line);
    }
}

function clearGuideLines() {
    guideLines.forEach(l => scene.remove(l));
    guideLines = [];
}

function onMouseUp() {
    if (!mouseState.isAiming) return;
    
    clearGuideLines();
    window.shootBall(mouseState.angle, mouseState.power);
    mouseState.isAiming = false;
    gameState.setState(GameStates.SHOOTING);
    cueStick.visible = false;
    aimLine.visible = false;
    controls.enabled = true;
}

function updateMouse(e) {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    window.renderer.setSize(window.innerWidth, window.innerHeight);
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 13/10 : js/menuManager.js
  Lignes :      242
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// menuManager.js
// Gestion des Ã©crans UI, transitions et logique de menu

import { gameState, GameStates } from './gameState.js';
import { botManager } from './botManager.js';

// Settings
export const settings = {
    musicVol: 0.5,
    sfxVol: 0.8,
    lang: 'fr'
};

// Textes (Localization)
const TEXTS = {
    fr: { 
        win: "VICTOIRE !", 
        lose: "DÃ‰FAITE...", 
        msgWin: "Table nettoyÃ©e !", 
        msgLose: "La blanche est tombÃ©e ou faute.",
        niceShotContinue: "Joli coup ! Rejouez.",
        foulScratch: "Faute ! Blanche empochÃ©e.",
        missedTurn: "RatÃ© ! Au tour de l'adversaire."
    },
    en: { 
        win: "YOU WIN!", 
        lose: "GAME OVER", 
        msgWin: "Table cleared!", 
        msgLose: "Scratch or foul.",
        niceShotContinue: "Nice shot! Play again.",
        foulScratch: "Foul! White ball pocketed.",
        missedTurn: "Missed! Opponent's turn."
    }
};

// Variables globales pour les callbacks
let onPlayCallback = null;
let onResetCallback = null;
let controls = null;

// MÃ©moriser l'Ã©tat avant d'aller dans SETTINGS
let previousState = null;

export function setMenuCallbacks(onPlay, onReset, ctrls) {
    onPlayCallback = onPlay;
    onResetCallback = onReset;
    controls = ctrls;
}

// Fonction principale pour changer d'Ã©tat et afficher le bon Ã©cran
export function switchState(newState) {
    gameState.setState(newState);
    
    // Cacher tous les Ã©crans
    ['screen-menu', 'screen-settings', 'screen-hud', 'screen-pause', 'screen-gameover'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });

    // Logique par Ã©tat
    switch(newState) {
        case GameStates.MENU:
            document.getElementById('screen-menu').style.display = 'flex';
            if (controls) controls.enabled = true;
            break;
            
        case GameStates.IDLE:
        case GameStates.AIMING:
        case GameStates.SHOOTING:
            document.getElementById('screen-hud').style.display = 'block';
            if (controls) controls.enabled = true;
            updateHUD();
            break;
            
        case GameStates.PAUSED:
            document.getElementById('screen-hud').style.display = 'block';
            document.getElementById('screen-pause').style.display = 'flex';
            if (controls) controls.enabled = false;
            break;
            
        case GameStates.SETTINGS:
            document.getElementById('screen-settings').style.display = 'flex';
            break;
            
        case GameStates.GAME_OVER:
            document.getElementById('screen-gameover').style.display = 'flex';
            if (controls) controls.enabled = false;
            break;
    }
}

// Mise Ã  jour du HUD
export function updateHUD() {
    const player = gameState.getCurrentPlayer();
    const t = TEXTS[settings.lang];
    
    const label = settings.lang === 'fr' ? `Joueur ${player}` : `Player ${player}`;
    const scoreDisplay = document.getElementById('score-display');
    const playerNameEl = scoreDisplay.querySelector('.player-name');
    const playerBallsEl = scoreDisplay.querySelector('.player-balls');
    
    // Mettre Ã  jour le nom du joueur
    if (playerNameEl) {
        playerNameEl.innerText = label;
    }
    
    // Couleur distinctive par joueur
    if (player === 1) {
        scoreDisplay.style.borderLeft = "5px solid #0055ff"; // Bleu pour J1
        scoreDisplay.style.color = "white";
    } else {
        scoreDisplay.style.borderLeft = "5px solid #ff5500"; // Orange pour J2
        scoreDisplay.style.color = "white";
    }
    
    // Afficher les balles capturÃ©es
    if (playerBallsEl) {
        const balls = gameState.getPlayerBalls(player);
        playerBallsEl.innerHTML = '';
        
        if (balls.length > 0) {
            balls.forEach(ballNum => {
                const badge = document.createElement('div');
                badge.className = 'ball-badge';
                
                // DÃ©terminer le type de balle (pleines 1-7, rayÃ©es 9-15)
                if (ballNum >= 1 && ballNum <= 7) {
                    badge.classList.add('solid');
                } else if (ballNum >= 9 && ballNum <= 15) {
                    badge.classList.add('striped');
                }
                
                badge.innerText = ballNum;
                playerBallsEl.appendChild(badge);
            });
        }
    }
}

// Afficher l'Ã©cran de fin de partie
export function triggerGameOver(isWin, reason) {
    switchState(GameStates.GAME_OVER);
    const t = TEXTS[settings.lang];
    document.getElementById('end-title').innerText = isWin ? t.win : t.lose;
    document.getElementById('end-message').innerText = reason || (isWin ? t.msgWin : t.msgLose);
    document.getElementById('end-title').style.color = isWin ? '#2e8b57' : '#8b0000';
}

// Configuration des Ã©vÃ©nements UI
export function setupUI() {
    // MENU - Mode de jeu
    // 1 JOUEUR (PvE)
    document.getElementById('btn-pve').onclick = () => {
        botManager.setEnabled(true, 0.6);
        botManager.setBotPlayer(2);
        startGame();
    };

    // 2 JOUEURS (PvP)
    document.getElementById('btn-pvp').onclick = () => {
        botManager.setEnabled(false);
        startGame();
    };

    // BOT vs BOT (Mode spectateur)
    document.getElementById('btn-bot-vs-bot').onclick = () => {
        botManager.setBotVsBot(0.6, 0.7); // Bot 1: 60%, Bot 2: 70%
        startGame();
    };

    function startGame() {
        if (onResetCallback) onResetCallback();
        switchState(GameStates.IDLE);
        if (onPlayCallback) onPlayCallback();
    }
    
    document.getElementById('btn-settings').onclick = () => {
        previousState = GameStates.MENU; // Vient du menu principal
        document.getElementById('screen-menu').style.display = 'none';
        switchState(GameStates.SETTINGS);
    };

    document.getElementById('btn-credits').onclick = () => {
        alert('Billard Master 3D\nDÃ©veloppÃ© avec Three.js\nÂ© 2024');
    };

    // SETTINGS
    document.getElementById('btn-back-menu').onclick = () => {
        document.getElementById('screen-settings').style.display = 'none';
        // Retour Ã  l'Ã©tat prÃ©cÃ©dent (MENU ou PAUSED)
        if(previousState === GameStates.PAUSED) {
            switchState(GameStates.PAUSED);
        } else {
            switchState(GameStates.MENU);
        }
        previousState = null; // Reset
    };
    
    document.getElementById('vol-music').oninput = (e) => { 
        settings.musicVol = parseFloat(e.target.value);
        // TODO: Update Audio when implemented
    };
    
    document.getElementById('vol-sfx').oninput = (e) => { 
        settings.sfxVol = parseFloat(e.target.value);
        // TODO: Update Audio when implemented
    };
    
    document.getElementById('lang-select').onchange = (e) => { 
        settings.lang = e.target.value;
        updateHUD();
    };

    // HUD / PAUSE
    document.getElementById('btn-pause').onclick = () => {
        switchState(GameStates.PAUSED);
    };
    
    document.getElementById('btn-resume').onclick = () => {
        switchState(GameStates.IDLE);
    };
    
    document.getElementById('btn-settings-pause').onclick = () => {
        previousState = GameStates.PAUSED; // Vient du menu pause
        document.getElementById('screen-pause').style.display = 'none';
        switchState(GameStates.SETTINGS);
    };
    
    document.getElementById('btn-quit').onclick = () => {
        switchState(GameStates.MENU);
    };

    // GAME OVER
    document.getElementById('btn-restart').onclick = () => {
        if (onResetCallback) onResetCallback();
        switchState(GameStates.IDLE);
    };
    
    document.getElementById('btn-quit-end').onclick = () => {
        switchState(GameStates.MENU);
    };
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FICHIER 14/10 : js/main.js
  Lignes :      350
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// main.js
// Point d'entrÃ©e principal : initialisation, boucle de jeu et gestion globale

import * as THREE from 'three';
import { OrbitControls } from 'jsm/controls/OrbitControls.js';
import { BilliardBall, setParams as setBallParams } from './ball.js';
import { createTable } from './table.js';
import { updatePhysics, setParams as setPhysicsParams } from './physics.js';
import { setupGUI, setupEventListeners, setGlobalVariables, updateWhiteBall } from './ui.js';
import { TABLE_W, TABLE_H, BALL_RADIUS, INERTIA, BALL_MASS } from './constants.js';
import { gameState, GameStates } from './gameState.js';
import { setupUI, switchState, triggerGameOver, setMenuCallbacks, updateHUD } from './menuManager.js';
import { botManager } from './botManager.js';

// --- PARAMÃˆTRES MODIFIABLES ---
export const params = {
    muSlide: 0.2,    // Coefficient de glissement (Tapis)
    muRoll: 0.07,    // RÃ©sistance au roulement
    restitution: 0.90, // Rebond billes
    wallRestitution: 0.6,
    maxPower: 25.0, 
    cueHeight: 0.0, 
    showDebug: false
};

// Variables globales
export let scene, camera, renderer, controls, gui;
export let balls = [], whiteBall;
let cueStick, aimLine;

// Suivi du tour actuel (pour le systÃ¨me 2 joueurs)
let turnInfo = {
    whiteScratched: false,
    ballsPotted: []
};

// Initialisation
init();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 12, 10);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // LumiÃ¨res - Ã‰clairage amÃ©liorÃ© pour bien voir le modÃ¨le
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));  // AugmentÃ© de 0.4 Ã  0.6
    
    // LumiÃ¨re principale (au-dessus)
    const mainLight = new THREE.SpotLight(0xffffff, 1200);  // AugmentÃ© de 800 Ã  1200
    mainLight.position.set(0, 15, 0);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(2048, 2048);
    mainLight.angle = Math.PI / 3;  // Angle plus large
    scene.add(mainLight);
    
    // LumiÃ¨res d'appoint pour Ã©viter les zones trop sombres
    const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight1.position.set(10, 10, 10);
    scene.add(fillLight1);
    
    const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
    fillLight2.position.set(-10, 10, -10);
    scene.add(fillLight2);

    // Configuration
    setBallParams(params);
    setPhysicsParams(params);

    // Construction de la scÃ¨ne
    createTable(scene);
    resetGame();
    createCue();
    
    // ContrÃ´les
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2 - 0.1;
    
    // UI et contrÃ´les
    setGlobalVariables(scene, camera, controls, whiteBall, cueStick, aimLine, params);
    gui = setupGUI(params);
    setupEventListeners();

    // Rendre les variables globales accessibles pour les fonctions UI
    window.balls = balls;
    window.whiteBall = whiteBall;
    window.renderer = renderer;
    window.resetGame = resetGame;
    window.resetWhiteBall = resetWhiteBall;
    window.shootBall = shootBall;

    // Setup menu system
    setMenuCallbacks(onGameStart, resetGame, controls);
    setupUI();
    switchState(GameStates.MENU);

    renderer.setAnimationLoop(animate);
}

function createCue() {
    const g = new THREE.CylinderGeometry(0.04, 0.08, 3, 12);
    g.rotateX(-Math.PI / 2);
    g.translate(0, 0, 1.7);
    
    cueStick = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color: 0xdeb887 }));
    scene.add(cueStick);
    cueStick.visible = false;

    aimLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0), 
            new THREE.Vector3(3, 0, 0)
        ]), 
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
    );
    scene.add(aimLine);
    aimLine.visible = false;
}

export function resetGame() {
    // Nettoyer les billes existantes
    balls.forEach(b => scene.remove(b.mesh));
    balls = [];
    
    // CrÃ©er la nouvelle configuration
    whiteBall = new BilliardBall(-TABLE_W / 4, 0, 0);
    scene.add(whiteBall.mesh);
    balls.push(whiteBall);
    
    const startX = TABLE_W / 4;
    const rS = BALL_RADIUS * 1.732;
    const cS = BALL_RADIUS * 2.01;
    const p = [1, 10, 2, 3, 8, 11, 12, 5, 13, 4, 6, 14, 7, 15, 9];
    
    let k = 0;
    for (let r = 0; r < 5; r++) {
        for (let i = 0; i <= r; i++) {
            const ball = new BilliardBall(startX + r * rS, (i - r / 2) * cS, p[k++]);
            scene.add(ball.mesh);
            balls.push(ball);
        }
    }
    
    // Mettre Ã  jour les variables globales
    window.balls = balls;
    window.whiteBall = whiteBall;
    
    // Update whiteBall reference in ui.js
    updateWhiteBall(whiteBall);
    
    // Reset game state only if not in menu
    if (!gameState.isMenu()) {
        gameState.setState(GameStates.IDLE);
    }
    
    // Reset au Joueur 1 et rÃ©initialiser les balles capturÃ©es
    gameState.resetPlayer();
    gameState.resetBalls();
    updateHUD();
}

function onGameStart() {
    // Called when game starts from menu
    console.log('Game started!');
    
    // Si c'est le mode Bot vs Bot ou si le Bot 1 doit jouer, le dÃ©clencher
    if (botManager.shouldBotPlay()) {
        setTimeout(() => {
            botManager.playBotTurn(whiteBall, balls, shootBall);
        }, 1000); // Petit dÃ©lai pour que le joueur voie la table
    }
}

export function resetWhiteBall() {
    whiteBall.inPocket = false;
    whiteBall.mesh.visible = true;
    whiteBall.pos.set(-TABLE_W / 4, BALL_RADIUS, 0);
    whiteBall.vel.set(0, 0, 0);
    whiteBall.angVel.set(0, 0, 0);
}

// --- NOUVEAU SHOOT : GÃ¨re correctement la vitesse angulaire ---
export function shootBall(angle, power) {
    // RÃ©initialiser les infos du tour au moment du tir
    turnInfo = {
        whiteScratched: false,
        ballsPotted: []
    };
    
    const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
    
    // 1. Vitesse LinÃ©aire
    const speed = power;
    whiteBall.vel.copy(dir.clone().multiplyScalar(speed));
    
    // 2. Vitesse Angulaire (Coup dÃ©centrÃ©)
    const h = params.cueHeight;
    const impactPoint = new THREE.Vector3(0, h, 0);
    
    // Force appliquÃ©e dans la direction du tir
    const forceDir = dir.clone();
    const forceMag = power * BALL_MASS * 50; // Facteur arbitraire pour sentir l'effet
    const forceVec = forceDir.multiplyScalar(forceMag);

    // Torque = r x F
    const torque = new THREE.Vector3().crossVectors(impactPoint, forceVec);
    
    // Angular Acc = Torque / Inertia -> AngVel += Angular Acc * dt (impulse approximation)
    const impulseDt = 0.01; // Temps de contact fictif
    whiteBall.angVel.add(torque.divideScalar(INERTIA).multiplyScalar(impulseDt));
    
    // IMPORTANT : Changer l'Ã©tat en SHOOTING pour que la physique dÃ©tecte la fin du mouvement
    gameState.setState(GameStates.SHOOTING);
}

// --- MOTEUR PHYSIQUE ---
function animate() {
    // Si PAUSED, on arrÃªte la physique mais on continue le rendu
    if (gameState.isPaused() || gameState.isSettings()) {
        renderer.render(scene, camera);
        return;
    }

    controls.update();
    
    // Physique active en MENU (pour l'effet visuel) et pendant le jeu
    if (gameState.isPlaying() || gameState.isMenu()) {
        // Passer turnInfo Ã  updatePhysics pour tracker les billes empochÃ©es
        updatePhysics(balls, 0.016, gameState.isPlaying() ? turnInfo : null);
        
        // Check if all balls have stopped moving (only during gameplay)
        if (gameState.isShooting()) {
            const allStopped = balls.every(b => 
                b.inPocket || b.vel.lengthSq() < 0.0001
            );
            
            if (allStopped) {
                gameState.setState(GameStates.IDLE);
                
                // Logique de changement de tour
                handleTurnEnd();
                
                checkWinCondition();
            }
        }
    }
    
    // Camera rotation in menu for visual effect
    if (gameState.isMenu()) {
        const time = Date.now() * 0.0003;
        camera.position.x = Math.sin(time) * 12;
        camera.position.z = Math.cos(time) * 12;
        camera.lookAt(0, 0, 0);
    }
    
    renderer.render(scene, camera);
}

// --- DETECTION FIN DE PARTIE (CORRIGÃ‰E - RÃ¨gles WPA 8-Ball) ---
function checkWinCondition() {
    // On ne vÃ©rifie que si le jeu est en cours
    if (!gameState.isPlaying()) return;
    
    const blackBall = balls.find(b => b.number === 8);

    // CAS CRITIQUE : La Noire est tombÃ©e
    if (blackBall && blackBall.inPocket) {
        
        // 1. Si la Blanche est AUSSI tombÃ©e en mÃªme temps -> DÃ‰FAITE
        if (whiteBall.inPocket) {
            triggerGameOver(false, "DÃ‰FAITE : Blanche et Noire empochÃ©es !");
            return;
        }

        // 2. VÃ©rifier si le joueur avait le droit de rentrer la noire
        // (Toutes les autres billes - sauf blanche et noire - doivent Ãªtre rentrÃ©es)
        const otherBalls = balls.filter(b => b.number !== 0 && b.number !== 8);
        const allOthersPocketed = otherBalls.every(b => b.inPocket);
        
        if (allOthersPocketed) {
            triggerGameOver(true, "VICTOIRE ! Table nettoyÃ©e.");
        } else {
            triggerGameOver(false, "DÃ‰FAITE : Noire empochÃ©e trop tÃ´t !");
        }
        return;
    }
    
    // Si SEULEMENT la blanche est tombÃ©e :
    // Ce n'est PAS un Game Over. C'est juste une faute.
    // La fonction handleTurnEnd() s'occupera de passer la main Ã  l'adversaire.
    // Et physics.js s'occupera de remettre la blanche sur la table via le setTimeout.
}

// --- GESTION DES TOURS (2 JOUEURS) ---
function handleTurnEnd() {
    let switchTurn = true;
    let message = "";

    // 1. Faute : La blanche est tombÃ©e
    if (turnInfo.whiteScratched) {
        message = "Faute ! Blanche empochÃ©e.";
        switchTurn = true;
    }
    // 2. SuccÃ¨s : Au moins une bille (autre que blanche/noire) est tombÃ©e
    else if (turnInfo.ballsPotted.length > 0) {
        const hasBlack = turnInfo.ballsPotted.includes(8);
        
        if (!hasBlack) {
            // Bon tir ! Le joueur garde la main
            // Enregistrer les balles capturÃ©es pour le joueur actuel
            turnInfo.ballsPotted.forEach(ballNum => {
                gameState.addBallToCurrentPlayer(ballNum);
            });
            switchTurn = false;
            message = "Joli coup ! Rejouez.";
        }
        // Si la noire est tombÃ©e, checkWinCondition() gÃ¨re la victoire/dÃ©faite
    }
    // 3. Rien n'est tombÃ©
    else {
        switchTurn = true;
        message = "RatÃ© ! Au tour de l'adversaire.";
    }

    if (switchTurn) {
        gameState.switchPlayer();
    }
    
    // Mettre Ã  jour l'affichage du joueur
    updateHUD();
    
    console.log(`Fin du tour. EmpochÃ©es: ${turnInfo.ballsPotted.length}. Faute: ${turnInfo.whiteScratched}. Prochain: J${gameState.getCurrentPlayer()}`);
    if (message) console.log(message);
    
    // NOUVEAU : VÃ©rifier si c'est au tour du bot
    if (botManager.shouldBotPlay()) {
        // Petit dÃ©lai pour que le joueur voie le changement
        setTimeout(() => {
            botManager.playBotTurn(whiteBall, balls, shootBall);
        }, 500);
    }
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  FIN DE LA COMPILATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Statistiques:
  - Fichiers compilÃ©s : 14/10
  - Lignes totales    : 2539
  - Date              : 13/12/2025 05:55:28

