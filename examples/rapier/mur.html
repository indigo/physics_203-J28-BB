<!DOCTYPE html>
<html lang="fr">
<head>
    <title>TP Rapier 3D - Tir Visé</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; user-select: none; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center; color: white;
            font-family: sans-serif; pointer-events: none; text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="info">Clic Gauche sur le sol pour Tirer • Clic Droit pour tourner</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/",
                "@dimforge/rapier3d-compat": "https://unpkg.com/@dimforge/rapier3d-compat@0.12.0/rapier.es.js",
                "lil-gui": "https://unpkg.com/lil-gui@0.20.0/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import RAPIER from '@dimforge/rapier3d-compat';
        import { GUI } from 'lil-gui';

        // --- Globales ---
        let camera, scene, renderer, controls;
        let world_rapier;
        
        // MODIF 1 : Variables pour le Raycasting (Visée)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let groundMesh; // Doit être globale pour être testée au clic

        let objectsToUpdate = []; 

        const params = {
            gravity: -9.81,
            brickMass: 2.0,
            brickFriction: 0.8, 
            brickRestitution: 0.1, 
            rows: 10,
            cols: 8,
            reset: () => createSceneContent()
        };

        // --- Initialisation ---
        async function init() {
            await RAPIER.init();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, 15); // Caméra un peu plus haute pour mieux viser le sol

            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 3, 0);

            initPhysicsWorld();
            createSceneContent();

            setupGUI();
            window.addEventListener('resize', onResize);
            window.addEventListener('mousedown', onMouseDown); 

            renderer.setAnimationLoop(animate);
        }

        function initPhysicsWorld() {
            world_rapier = new RAPIER.World({ x: 0.0, y: params.gravity, z: 0.0 });
        }

        function createSceneContent() {
            // Nettoyage
            for (const obj of objectsToUpdate) {
                scene.remove(obj.mesh);
                if (world_rapier.getRigidBody(obj.body.handle)) {
                    world_rapier.removeRigidBody(obj.body);
                }
            }
            objectsToUpdate = [];

            // A. LE SOL (Statique)
            const groundGeo = new THREE.BoxGeometry(50, 1, 50);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x556677 });
            
            // MODIF 2 : On assigne la variable globale groundMesh
            groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.position.y = -0.5; 
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, -0.5, 0);
            const groundBody = world_rapier.createRigidBody(groundBodyDesc);
            const groundCollider = RAPIER.ColliderDesc.cuboid(25, 0.5, 25).setFriction(1.0);
            world_rapier.createCollider(groundCollider, groundBody);

            // B. LE MUR
            const brickW = 1.0;
            const brickH = 0.6;
            const brickD = 0.5;
            const margin = 0.05; 

            for (let y = 0; y < params.rows; y++) {
                for (let x = 0; x < params.cols; x++) {
                    let xOffset = (y % 2 === 0) ? 0 : brickW / 2;
                    let px = (x * (brickW + margin)) - (params.cols * brickW / 2) + xOffset;
                    let py = brickH / 2 + y * (brickH + margin); 
                    createBrick(px, py, 0, brickW, brickH, brickD);
                }
            }
        }

        function createBrick(x, y, z, w, h, d) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ 
                color: Math.random() > 0.5 ? 0xcc5544 : 0xcc7755,
                roughness: 0.8
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                .setTranslation(x, y, z)
                .setCanSleep(true); 
            const body = world_rapier.createRigidBody(bodyDesc);

            const colliderDesc = RAPIER.ColliderDesc.cuboid(w/2, h/2, d/2)
                .setMass(params.brickMass)
                .setFriction(params.brickFriction)     
                .setRestitution(params.brickRestitution); 
            world_rapier.createCollider(colliderDesc, body);

            objectsToUpdate.push({ mesh, body });
        }

        // MODIF 3 : Fonction de tir qui accepte une CIBLE (targetPoint)
        function shootBallTo(targetPoint) {
            const origin = camera.position;
            
            // Calcul du vecteur direction : (Target - Origin) normalisé
            const direction = new THREE.Vector3().subVectors(targetPoint, origin).normalize();

            // Visuel
            const radius = 0.4;
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(radius),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 })
            );
            mesh.castShadow = true;
            scene.add(mesh);

            // Physique
            // On part un peu devant la caméra (2 unités) dans la direction du tir
            const startPos = origin.clone().add(direction.clone().multiplyScalar(2.0));
            
            const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                .setTranslation(startPos.x, startPos.y, startPos.z)
                .setCcdEnabled(true);
            
            const body = world_rapier.createRigidBody(bodyDesc);
            const collider = RAPIER.ColliderDesc.ball(radius)
                .setDensity(5.0)
                .setRestitution(0.5);
            world_rapier.createCollider(collider, body);

            // IMPULSION vers la cible
            const force = 60.0;
            body.applyImpulse({ 
                x: direction.x * force, 
                y: direction.y * force, 
                z: direction.z * force 
            }, true);

            const objectContext = { mesh, body };
            objectsToUpdate.push(objectContext);

            // Nettoyage sécurisé
            setTimeout(() => {
                const index = objectsToUpdate.indexOf(objectContext);
                if (index > -1) {
                    objectsToUpdate.splice(index, 1);
                    scene.remove(mesh);
                    if (world_rapier.getRigidBody(body.handle)) {
                        world_rapier.removeRigidBody(body);
                    }
                }
            }, 5000);
        }

        // MODIF 4 : Gestion du clic avec Raycasting
        function onMouseDown(event) {
            if (event.button === 0) { // Clic gauche
                
                // 1. Coordonnées souris normalisées (-1 à +1)
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // 2. Lancer le rayon depuis la caméra
                raycaster.setFromCamera(mouse, camera);

                // 3. Tester l'intersection avec le sol
                // (On pourrait aussi tester intersection avec 'scene.children' pour tirer sur le mur)
                const intersects = raycaster.intersectObject(groundMesh);

                if (intersects.length > 0) {
                    // 4. On tire vers le point d'impact
                    shootBallTo(intersects[0].point);
                    
                    // Petit effet visuel : un marqueur là où on a cliqué
                    createClickMarker(intersects[0].point);
                }
            }
        }
        
        // Petit bonus visuel pour voir où on vise
        function createClickMarker(pos) {
            const marker = new THREE.Mesh(
                new THREE.RingGeometry(0.2, 0.3, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
            );
            marker.position.copy(pos);
            marker.position.y += 0.05; // Juste au dessus du sol
            marker.rotation.x = -Math.PI / 2;
            scene.add(marker);
            setTimeout(() => scene.remove(marker), 500);
        }

        function animate() {
            world_rapier.step();

            for (let i = 0; i < objectsToUpdate.length; i++) {
                const obj = objectsToUpdate[i];
                try {
                    const t = obj.body.translation();
                    const r = obj.body.rotation();
                    obj.mesh.position.set(t.x, t.y, t.z);
                    obj.mesh.quaternion.set(r.x, r.y, r.z, r.w);
                } catch (e) {
                    objectsToUpdate.splice(i, 1);
                    i--;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function setupGUI() {
            const gui = new GUI({ title: "TP Paramètres" });
            gui.add(params, 'reset').name('Reconstruire le mur');
            gui.add(params, 'rows', 2, 20, 1).name('Hauteur');
            gui.add(params, 'cols', 2, 20, 1).name('Largeur');
            
            const folderPhys = gui.addFolder('Matériau Brique');
            folderPhys.add(params, 'brickFriction', 0.0, 2.0).name('Friction');
            folderPhys.add(params, 'brickRestitution', 0.0, 1.0).name('Rebond');
            folderPhys.add(params, 'brickMass', 0.1, 10.0).name('Masse');
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>