<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Demo Rapier.js - Balle Tombante</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Configuration des imports modernes -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/",
                "@dimforge/rapier2d-compat": "https://unpkg.com/@dimforge/rapier2d-compat@0.12.0/rapier.es.js",
                "lil-gui": "https://unpkg.com/lil-gui@0.20.0/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import RAPIER from '@dimforge/rapier2d-compat';
        import { GUI } from 'lil-gui';

        // --- Variables Globales ---
        let camera, scene, renderer, controls;
        let clock = new THREE.Clock();

        // Objets Three.js
        let groundMesh_three, dynamicBoxMesh_three;

        // Objets Rapier
        let world_rapier;
        let dynamicBoxBody_rapier;
        
        // Param√®tres de simulation (accessibles via GUI)
        const simParams = {
            gravityY: -9.81,
            boxSize: 0.5,
            boxInitialY: 4.0,
            boxMass: 1.0,
            boxRestitution: 0.7,
            groundY: -0.0,
            groundSizeX: 10.0,
            groundSizeZ: 10.0,
            groundRestitution: 0.5,
            reset: function() { resetSimulation(); }
        };

        // --- Initialisation ---
        async function init() {
            // 1. Initialisation de Rapier (WASM)
            try {
                await RAPIER.init();
                console.log("‚úÖ Rapier.js (WASM) charg√©.");
            } catch (e) {
                console.error("‚ùå Erreur Rapier:", e);
                return;
            }

            // 2. Initialisation Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202020);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 8);

            const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
            scene.add(ambient);

            const light = new THREE.DirectionalLight(0xffffff, 2.0);
            light.position.set(5, 10, 7);
            light.castShadow = true;
            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // 3. Cr√©ation du monde physique et visuel
            resetSimulation();

            // 4. Interface GUI
            setupGUI();

            // 5. Boucle de rendu
            window.addEventListener('resize', onWindowResize, false);
            renderer.setAnimationLoop(animate);
        }

        // --- Gestion Physique ---
        function createPhysicsWorld() {
            // Nettoyage de l'ancien monde pour √©viter les fuites de m√©moire
            if (world_rapier) {
                world_rapier.free(); 
            }

            const gravity = { x: 0.0, y: simParams.gravityY };
            world_rapier = new RAPIER.World(gravity);

            // A. Le Sol (Statique)
            const groundDesc = RAPIER.RigidBodyDesc.fixed()
                .setTranslation(0.0, simParams.groundY, 0.0);
            const groundBody = world_rapier.createRigidBody(groundDesc);
            
            const groundColliderDesc = RAPIER.ColliderDesc.cuboid(simParams.groundSizeX / 2, 0.01)
                .setRestitution(simParams.groundRestitution);
            world_rapier.createCollider(groundColliderDesc, groundBody);

            // B. La Bo√Æte (Dynamique)
            // Note: En 2D Rapier, rotation = float. En 3D = Quaternion. Ici on utilise Rapier2D Compat.
            const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                .setTranslation(0.0, simParams.boxInitialY)
                .setCanSleep(false); // Emp√™che l'objet de s'endormir pour la d√©mo
            
            dynamicBoxBody_rapier = world_rapier.createRigidBody(bodyDesc);

            const colliderDesc = RAPIER.ColliderDesc.cuboid(simParams.boxSize, simParams.boxSize)
                .setRestitution(simParams.boxRestitution)
                .setMass(simParams.boxMass);
            world_rapier.createCollider(colliderDesc, dynamicBoxBody_rapier);
        }

        // --- Gestion Visuelle ---
        function createVisuals() {
            // Nettoyage
            if (groundMesh_three) scene.remove(groundMesh_three);
            if (dynamicBoxMesh_three) scene.remove(dynamicBoxMesh_three);

            // Sol
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x445566, metalness: 0.2, roughness: 0.5 });
            const floorGeo = new THREE.PlaneGeometry(simParams.groundSizeX, simParams.groundSizeZ);
            groundMesh_three = new THREE.Mesh(floorGeo, floorMat);
            groundMesh_three.rotation.x = -Math.PI / 2;
            groundMesh_three.position.y = 0;//imParams.groundY;
            groundMesh_three.receiveShadow = true;
            scene.add(groundMesh_three);

            // Bo√Æte
            const boxGeo = new THREE.BoxGeometry(simParams.boxSize * 2, simParams.boxSize * 2, simParams.boxSize * 2);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, metalness: 0.4, roughness: 0.2 });
            dynamicBoxMesh_three = new THREE.Mesh(boxGeo, boxMat);
            dynamicBoxMesh_three.castShadow = true;
            scene.add(dynamicBoxMesh_three);
        }

        function resetSimulation() {
            createPhysicsWorld();
            createVisuals();
            clock.start();
            console.log("üîÑ Simulation r√©initialis√©e");
        }

        function animate() {
            if (world_rapier && dynamicBoxMesh_three) {
                // Step Physique (60Hz par d√©faut)
                world_rapier.step();

                // Synchronisation Rapier -> Three.js
                // Attention: Rapier2D travaille en x,y. Three.js en x,y,z.
                const pos = dynamicBoxBody_rapier.translation();
                const rot = dynamicBoxBody_rapier.rotation();

                dynamicBoxMesh_three.position.set(pos.x, pos.y, 0);
                dynamicBoxMesh_three.rotation.z = rot;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function setupGUI() {
            const gui = new GUI({ title: "Param√®tres" });
            
            gui.add(simParams, 'reset').name('‚ôªÔ∏è R√©initialiser');

            const folderPhys = gui.addFolder('Physique Rapier');
            folderPhys.add(simParams, 'gravityY', -20.0, 0.0).name('Gravit√© Y').onChange(resetSimulation);
            folderPhys.add(simParams, 'boxMass', 0.1, 10.0).name('Masse Bo√Æte').onChange(resetSimulation);
            folderPhys.add(simParams, 'boxRestitution', 0.0, 1.2).name('Rebond (0-1.2)').onChange(resetSimulation);
            folderPhys.add(simParams, 'groundRestitution', 0.0, 1.2).name('Rebond Sol').onChange(resetSimulation);
            
            const folderScene = gui.addFolder('Sc√®ne');
            folderScene.add(simParams, 'boxSize', 0.1, 1.0).name('Taille Bo√Æte').onChange(resetSimulation);
            folderScene.add(simParams, 'boxInitialY', 0.0, 10.0).name('Hauteur Initiale').onChange(resetSimulation);
            
            folderPhys.open();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Lancement
        init();
    </script>
</body>
</html>