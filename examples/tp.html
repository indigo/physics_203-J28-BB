<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TP Templage - Basedf on Physique Billard - Frottement & Rotation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'jsm/controls/OrbitControls.js';
        import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

        // --- Configuration ---
        const TABLE_SIZE_X = 10;
        const TABLE_SIZE_Z = 6;
        const BALL_RADIUS = 0.5;
        const BALL_MASS = 0.2; // kg standard

        // Constantes Physiques
        const GRAVITY = 9.81;
        const MU_SLIDE = 0.2;  // Coeff frottement glissement
        const MU_ROLL = 0.02;  // Coeff résistance roulement

        // Moment d'inertie Sphère Pleine : I = 2/5 * m * R²
        const INERTIA = 0.4 * BALL_MASS * BALL_RADIUS * BALL_RADIUS;

        let camera, scene, renderer, controls;
        let ballMesh, velArrow, slideArrow;

        // État Physique de la boule
        const physicsState = {
            pos: new THREE.Vector3(0, BALL_RADIUS, 0),
            vel: new THREE.Vector3(0, 0, 0),       
            angVel: new THREE.Vector3(0, 0, 0),    
            quat: new THREE.Quaternion(),          
            isSliding: false                       
        };

        // Paramètres GUI
        const params = {
            impulseForce: 5.0,     
            impactHeight: 0.0,     
            timeScale: 1.0,
            reset: resetGame,
            shoot: shootBall
        };

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const spotLight = new THREE.SpotLight(0xffffff, 50);
            spotLight.position.set(0, 10, 0);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            scene.add(spotLight);
            scene.add(new THREE.AmbientLight(0x404040));

            createTable();
            createBall();
            setupGUI();

            controls = new OrbitControls(camera, renderer.domElement);
            window.addEventListener('resize', onResize);
            renderer.setAnimationLoop(animate);
        }

        function createTable() {
            const floorGeo = new THREE.PlaneGeometry(TABLE_SIZE_X, TABLE_SIZE_Z);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x228822, roughness: 0.8 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallHeight = 0.5;
            const wallThick = 0.5;
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x335533 });

            const walls = [
                { pos: [0, wallHeight/2, -TABLE_SIZE_Z/2 - wallThick/2], size: [TABLE_SIZE_X + wallThick*2, wallHeight, wallThick] },
                { pos: [0, wallHeight/2, TABLE_SIZE_Z/2 + wallThick/2], size: [TABLE_SIZE_X + wallThick*2, wallHeight, wallThick] },
                { pos: [-TABLE_SIZE_X/2 - wallThick/2, wallHeight/2, 0], size: [wallThick, wallHeight, TABLE_SIZE_Z] },
                { pos: [TABLE_SIZE_X/2 + wallThick/2, wallHeight/2, 0], size: [wallThick, wallHeight, TABLE_SIZE_Z] }
            ];

            walls.forEach(w => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
                mesh.position.set(...w.pos);
                mesh.castShadow = true;
                scene.add(mesh);
            });
        }

        function createBall() {
            const tex = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/uv_grid_opengl.jpg');
            
            const geo = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ map: tex });
            ballMesh = new THREE.Mesh(geo, mat);
            ballMesh.castShadow = true;
            scene.add(ballMesh);

            velArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 1, 0x0000ff);
            scene.add(velArrow);

            slideArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 1, 0xff0000);
            scene.add(slideArrow);
        }

        function shootBall() {
            resetGame();

            // 1. Linéaire
            const direction = new THREE.Vector3(1, 0, 0); 
            const linearSpeed = params.impulseForce / BALL_MASS;
            physicsState.vel.copy(direction.multiplyScalar(linearSpeed));

            // 2. Angulaire (Coup décentré)
            const h = params.impactHeight; 
            const r = new THREE.Vector3(0, h, 0);
            const F = new THREE.Vector3(params.impulseForce, 0, 0);
            
            const torqueImpulse = new THREE.Vector3().crossVectors(r, F); 
            const deltaOmega = torqueImpulse.divideScalar(INERTIA);
            physicsState.angVel.copy(deltaOmega);
        }

        function updatePhysics(dt) {
            if (dt > 0.1) dt = 0.1;

            const v = physicsState.vel;
            const omega = physicsState.angVel;

            // Vitesse du point de contact
            const rVector = new THREE.Vector3(0, -BALL_RADIUS, 0);
            const rotationalVelAtPoint = new THREE.Vector3().crossVectors(omega, rVector);
            const slideVel = new THREE.Vector3().addVectors(v, rotationalVelAtPoint);
            slideVel.y = 0;

            const slideSpeed = slideVel.length();
            
            // Condition de Glissement vs Roulement
            if (slideSpeed > 0.05) {
                physicsState.isSliding = true;

                // Force de Friction Cinétique
                const frictionDir = slideVel.clone().normalize().negate();
                const frictionMag = MU_SLIDE * BALL_MASS * GRAVITY;
                const frictionForce = frictionDir.multiplyScalar(frictionMag);

                // A. Effet Linéaire
                const linearAcc = frictionForce.clone().divideScalar(BALL_MASS);
                v.addScaledVector(linearAcc, dt);

                // B. Effet Angulaire
                const torque = new THREE.Vector3().crossVectors(rVector, frictionForce);
                const angularAcc = torque.divideScalar(INERTIA);
                omega.addScaledVector(angularAcc, dt);

            } else {
                physicsState.isSliding = false;
                
                // Mode Roulement : Résistance simple
                const dragFactor = 1 - (MU_ROLL * dt * 60); // Ajustement empirique pour le dt
                v.multiplyScalar(dragFactor);
                omega.multiplyScalar(dragFactor);

                if (v.lengthSq() < 0.001) {
                    v.set(0,0,0);
                    omega.set(0,0,0);
                }
            }

            // Intégration
            physicsState.pos.addScaledVector(v, dt);

            const axis = omega.clone().normalize();
            const angle = omega.length() * dt;
            if (angle > 0.000001) {
                const q = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                physicsState.quat.premultiply(q);
            }

            // Murs
            const halfX = TABLE_SIZE_X/2 - BALL_RADIUS;
            const halfZ = TABLE_SIZE_Z/2 - BALL_RADIUS;

            if (physicsState.pos.x > halfX) { physicsState.pos.x = halfX; v.x *= -0.8; }
            if (physicsState.pos.x < -halfX) { physicsState.pos.x = -halfX; v.x *= -0.8; }
            if (physicsState.pos.z > halfZ) { physicsState.pos.z = halfZ; v.z *= -0.8; }
            if (physicsState.pos.z < -halfZ) { physicsState.pos.z = -halfZ; v.z *= -0.8; }
        }

        function updateVisuals() {
            ballMesh.position.copy(physicsState.pos);
            ballMesh.quaternion.copy(physicsState.quat);

            if (physicsState.vel.length() > 0.1) {
                velArrow.position.copy(physicsState.pos);
                velArrow.setDirection(physicsState.vel.clone().normalize());
                velArrow.setLength(physicsState.vel.length() * 0.5 + 0.5);
                velArrow.visible = true;
            } else {
                velArrow.visible = false;
            }

            const rVector = new THREE.Vector3(0, -BALL_RADIUS, 0);
            const vRot = new THREE.Vector3().crossVectors(physicsState.angVel, rVector);
            const vSlide = new THREE.Vector3().addVectors(physicsState.vel, vRot); vSlide.y = 0;

            if (physicsState.isSliding && vSlide.length() > 0.1) {
                slideArrow.position.copy(physicsState.pos);
                slideArrow.position.y -= BALL_RADIUS * 0.8; 
                slideArrow.setDirection(vSlide.normalize());
                slideArrow.setLength(vSlide.length() + 0.5);
                slideArrow.visible = true;
            } else {
                slideArrow.visible = false;
            }
        }

        function resetGame() {
            physicsState.pos.set(-4, BALL_RADIUS, 0);
            physicsState.vel.set(0, 0, 0);
            physicsState.angVel.set(0, 0, 0);
            physicsState.quat.identity();
        }

        function setupGUI() {
            const gui = new GUI();
            const folder = gui.addFolder('Coup de Queue');
            folder.add(params, 'impulseForce', 1, 20).name('Force (N)');
            folder.add(params, 'impactHeight', -BALL_RADIUS*0.9, BALL_RADIUS*0.9, 0.01).name('Hauteur Impact (h)');
            folder.add(params, 'shoot').name("TIRER !");
            gui.add(params, 'timeScale', 0.0, 1.0).name('Vitesse Temps');
            gui.add(params, 'reset').name('Reset');
        }

        function animate() {
            updatePhysics(0.016 * params.timeScale);
            updateVisuals();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>